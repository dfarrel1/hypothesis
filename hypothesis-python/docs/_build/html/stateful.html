

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Stateful testing &mdash; Hypothesis 4.28.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Compatibility" href="supported.html" />
    <link rel="prev" title="The Hypothesis Example Database" href="database.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Hypothesis
          

          
          </a>

          
            
            
              <div class="version">
                4.28.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick start guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="details.html">Details and advanced features</a></li>
<li class="toctree-l1"><a class="reference internal" href="settings.html">Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html">What you can generate and how</a></li>
<li class="toctree-l1"><a class="reference internal" href="extras.html">First-party extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="django.html">Hypothesis for Django users</a></li>
<li class="toctree-l1"><a class="reference internal" href="numpy.html">Hypothesis for the Scientific Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="healthchecks.html">Health checks</a></li>
<li class="toctree-l1"><a class="reference internal" href="database.html">The Hypothesis Example Database</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Stateful testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#you-may-not-need-state-machines">You may not need state machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rule-based-state-machines">Rule based state machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rules">Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initializes">Initializes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#preconditions">Preconditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#invariants">Invariants</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generic-state-machines">Generic state machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-fine-grained-control">More fine grained control</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="supported.html">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Some more examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="manifesto.html">The Purpose of Hypothesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="endorsements.html">Testimonials</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Open Source Projects using Hypothesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="strategies.html">Projects extending Hypothesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Ongoing Hypothesis Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Help and Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="packaging.html">Packaging Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="reproducing.html">Reproducing Failures</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Hypothesis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Stateful testing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/stateful.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="stateful-testing">
<h1>Stateful testing<a class="headerlink" href="#stateful-testing" title="Permalink to this headline">¶</a></h1>
<p>With <a class="reference internal" href="details.html#hypothesis.given" title="hypothesis.given"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;given</span></code></a>, your tests are still something that
you mostly write yourself, with Hypothesis providing some data.
With Hypothesis’s <em>stateful testing</em>, Hypothesis instead tries to generate
not just data but entire tests. You specify a number of primitive
actions that can be combined together, and then Hypothesis will
try to find sequences of those actions that result in a failure.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This style of testing is often called <em>model-based testing</em>, but in Hypothesis
is called <em>stateful testing</em> (mostly for historical reasons - the original
implementation of this idea in Hypothesis was more closely based on
<a class="reference external" href="https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md#stateful-testing">ScalaCheck’s stateful testing</a>
where the name is more apt).
Both of these names are somewhat misleading: You don’t really need any sort of
formal model of your code to use this, and it can be just as useful for pure APIs
that don’t involve any state as it is for stateful ones.</p>
<p>It’s perhaps best to not take the name of this sort of testing too seriously.
Regardless of what you call it, it is a powerful form of testing which is useful
for most non-trivial APIs.</p>
</div>
<p>Hypothesis has two stateful testing APIs: A high level one, providing what
we call <em>rule based state machines</em>, and a low level one, providing what we call
<em>generic state machines</em>.</p>
<p>You probably want to use the rule based state machines - they provide a high
level API for describing the sort of actions you want to perform, based on a
structured representation of actions. However the generic state machines are
more flexible, and are particularly useful if you want the set of currently
possible actions to depend primarily on external state.</p>
<div class="section" id="you-may-not-need-state-machines">
<span id="data-as-state-machine"></span><h2>You may not need state machines<a class="headerlink" href="#you-may-not-need-state-machines" title="Permalink to this headline">¶</a></h2>
<p>The basic idea of stateful testing is to make Hypothesis choose actions as
well as values for your test, and state machines are a great declarative way
to do just that.</p>
<p>For simpler cases though, you might not need them at all - a standard test
with <a class="reference internal" href="details.html#hypothesis.given" title="hypothesis.given"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;given</span></code></a> might be enough, since you can use
<a class="reference internal" href="data.html#hypothesis.strategies.data" title="hypothesis.strategies.data"><code class="xref py py-func docutils literal notranslate"><span class="pre">data()</span></code></a> in branches or loops.  In fact, that’s
how the state machine explorer works internally.  For more complex workloads
though, where a higher level API comes into it’s own, keep reading!</p>
</div>
<div class="section" id="rule-based-state-machines">
<span id="rulebasedstateful"></span><h2>Rule based state machines<a class="headerlink" href="#rule-based-state-machines" title="Permalink to this headline">¶</a></h2>
<p>Rule based state machines are the ones you’re most likely to want to use.
They’re significantly more user friendly and should be good enough for most
things you’d want to do.</p>
<dl class="class">
<dt id="hypothesis.stateful.RuleBasedStateMachine">
<em class="property">class </em><code class="sig-prename descclassname">hypothesis.stateful.</code><code class="sig-name descname">RuleBasedStateMachine</code><a class="reference internal" href="_modules/hypothesis/stateful.html#RuleBasedStateMachine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.stateful.RuleBasedStateMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>A RuleBasedStateMachine gives you a more structured way to define state
machines.</p>
<p>The idea is that a state machine carries a bunch of types of data
divided into Bundles, and has a set of rules which may read data
from bundles (or just from normal strategies) and push data onto
bundles. At any given point a random applicable rule will be
executed.</p>
</dd></dl>

<p>A rule is very similar to a normal <code class="docutils literal notranslate"><span class="pre">&#64;given</span></code> based test in that it takes
values drawn from strategies and passes them to a user defined test function.
The key difference is that where <code class="docutils literal notranslate"><span class="pre">&#64;given</span></code> based tests must be independent,
rules can be chained together - a single test run may involve multiple rule
invocations, which may interact in various ways.</p>
<p>Rules can take normal strategies as arguments, or a specific kind of strategy
called a Bundle.  A Bundle is a named collection of generated values that can
be reused by other operations in the test.
They are populated with the results of rules, and may be used as arguments to
rules, allowing data to flow from one rule to another, and rules to work on
the results of previous computations or actions.</p>
<p>You can think of each value that gets added to any Bundle as being assigned to
a new variable.  Drawing a value from the bundle strategy means choosing one of
the corresponding variables and using that value, and
<a class="reference internal" href="#hypothesis.stateful.consumes" title="hypothesis.stateful.consumes"><code class="xref py py-func docutils literal notranslate"><span class="pre">consumes()</span></code></a> as a <code class="docutils literal notranslate"><span class="pre">del</span></code> statement for that variable.
If you can replace use of Bundles with instance attributes of the class that
is often simpler, but often Bundles are strictly more powerful.</p>
<p>The following rule based state machine example is a simplified version of a
test for Hypothesis’s example database implementation. An example database
maps keys to sets of values, and in this test we compare one implementation of
it to a simplified in memory model of its behaviour, which just stores the same
values in a Python <code class="docutils literal notranslate"><span class="pre">dict</span></code>. The test then runs operations against both the
real database and the in-memory representation of it and looks for discrepancies
in their behaviour.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">hypothesis.strategies</span> <span class="kn">as</span> <span class="nn">st</span>
<span class="kn">from</span> <span class="nn">hypothesis.database</span> <span class="kn">import</span> <span class="n">DirectoryBasedExampleDatabase</span>
<span class="kn">from</span> <span class="nn">hypothesis.stateful</span> <span class="kn">import</span> <span class="n">Bundle</span><span class="p">,</span> <span class="n">RuleBasedStateMachine</span><span class="p">,</span> <span class="n">rule</span>


<span class="k">class</span> <span class="nc">DatabaseComparison</span><span class="p">(</span><span class="n">RuleBasedStateMachine</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DatabaseComparison</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tempd</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">DirectoryBasedExampleDatabase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tempd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="n">Bundle</span><span class="p">(</span><span class="s1">&#39;keys&#39;</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">Bundle</span><span class="p">(</span><span class="s1">&#39;values&#39;</span><span class="p">)</span>

    <span class="nd">@rule</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">binary</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">add_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">k</span>

    <span class="nd">@rule</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">binary</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">add_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="nd">@rule</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="nd">@rule</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="nd">@rule</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">values_agree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">teardown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tempd</span><span class="p">)</span>


<span class="n">TestDBComparison</span> <span class="o">=</span> <span class="n">DatabaseComparison</span><span class="o">.</span><span class="n">TestCase</span>
</pre></div>
</div>
<p>In this we declare two bundles - one for keys, and one for values.
We have two trivial rules which just populate them with data (<code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code>),
and three non-trivial rules:
<code class="docutils literal notranslate"><span class="pre">save</span></code> saves a value under a key and <code class="docutils literal notranslate"><span class="pre">delete</span></code> removes a value from a key,
in both cases also updating the model of what <em>should</em> be in the database.
<code class="docutils literal notranslate"><span class="pre">values_agree</span></code> then checks that the contents of the database agrees with the
model for a particular key.</p>
<p>We can then integrate this into our test suite by getting a unittest TestCase
from it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TestTrees</span> <span class="o">=</span> <span class="n">DatabaseComparison</span><span class="o">.</span><span class="n">TestCase</span>

<span class="c1"># Or just run with pytest&#39;s unittest support</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>This test currently passes, but if we comment out the line where we call <code class="docutils literal notranslate"><span class="pre">self.model[k].discard(v)</span></code>,
we would see the following output when run under pytest:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ne">AssertionError</span><span class="p">:</span> <span class="k">assert</span> <span class="nb">set</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span><span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">}</span>

<span class="o">------------</span> <span class="n">Hypothesis</span> <span class="o">------------</span>

<span class="n">state</span> <span class="o">=</span> <span class="n">DatabaseComparison</span><span class="p">()</span>
<span class="n">var1</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">add_key</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">var2</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">var1</span><span class="p">)</span>
<span class="n">state</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">var1</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">var2</span><span class="p">)</span>
<span class="n">state</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">var1</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">var2</span><span class="p">)</span>
<span class="n">state</span><span class="o">.</span><span class="n">values_agree</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">var1</span><span class="p">)</span>
<span class="n">state</span><span class="o">.</span><span class="n">teardown</span><span class="p">()</span>
</pre></div>
</div>
<p>Note how it’s printed out a very short program that will demonstrate the
problem. The output from a rule based state machine should generally be pretty
close to Python code - if you have custom <code class="docutils literal notranslate"><span class="pre">repr</span></code> implementations that don’t
return valid Python then it might not be, but most of the time you should just
be able to copy and paste the code into a test to reproduce it.</p>
<p>You can control the detailed behaviour with a settings object on the TestCase
(this is a normal hypothesis settings object using the defaults at the time
the TestCase class was first referenced). For example if you wanted to run
fewer examples with larger programs you could change the settings to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">DatabaseComparison</span><span class="o">.</span><span class="n">TestCase</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span><span class="p">(</span><span class="n">max_examples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">stateful_step_count</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Which doubles the number of steps each program runs and halves the number of
test cases that will be run.</p>
</div>
<div class="section" id="rules">
<h2>Rules<a class="headerlink" href="#rules" title="Permalink to this headline">¶</a></h2>
<p>As said earlier, rules are the most common feature used in RuleBasedStateMachine.
They are defined by applying the <a class="reference internal" href="#hypothesis.stateful.rule" title="hypothesis.stateful.rule"><code class="xref py py-func docutils literal notranslate"><span class="pre">rule()</span></code></a> decorator
on a function.
Note that RuleBasedStateMachine must have at least one rule defined and that
a single function cannot be used to define multiple rules (this to avoid having
multiple rules doing the same things).
Due to the stateful execution method, rules generally cannot take arguments
from other sources such as fixtures or <code class="docutils literal notranslate"><span class="pre">pytest.mark.parametrize</span></code> - consider
providing them via a strategy such as <a class="reference internal" href="data.html#hypothesis.strategies.sampled_from" title="hypothesis.strategies.sampled_from"><code class="xref py py-func docutils literal notranslate"><span class="pre">sampled_from()</span></code></a>
instead.</p>
<dl class="function">
<dt id="hypothesis.stateful.rule">
<code class="sig-prename descclassname">hypothesis.stateful.</code><code class="sig-name descname">rule</code><span class="sig-paren">(</span><em class="sig-param">targets=()</em>, <em class="sig-param">target=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/stateful.html#rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.stateful.rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for RuleBasedStateMachine. Any name present in target or
targets will define where the end result of this function should go. If
both are empty then the end result will be discarded.</p>
<p><code class="docutils literal notranslate"><span class="pre">target</span></code> must be a Bundle, or if the result should go to multiple
bundles you can pass a tuple of them as the <code class="docutils literal notranslate"><span class="pre">targets</span></code> argument.
It is invalid to use both arguments for a single rule.  If the result
should go to exactly one of several bundles, define a separate rule for
each case.</p>
<p>kwargs then define the arguments that will be passed to the function
invocation. If their value is a Bundle, or if it is <code class="docutils literal notranslate"><span class="pre">consumes(b)</span></code>
where <code class="docutils literal notranslate"><span class="pre">b</span></code> is a Bundle, then values that have previously been produced
for that bundle will be provided. If <code class="docutils literal notranslate"><span class="pre">consumes</span></code> is used, the value
will also be removed from the bundle.</p>
<p>Any other kwargs should be strategies and values from them will be
provided.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.stateful.consumes">
<code class="sig-prename descclassname">hypothesis.stateful.</code><code class="sig-name descname">consumes</code><span class="sig-paren">(</span><em class="sig-param">bundle</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/stateful.html#consumes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.stateful.consumes" title="Permalink to this definition">¶</a></dt>
<dd><p>When introducing a rule in a RuleBasedStateMachine, this function can
be used to mark bundles from which each value used in a step with the
given rule should be removed. This function returns a strategy object
that can be manipulated and combined like any other.</p>
<p>For example, a rule declared with</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;rule(value1=b1,</span> <span class="pre">value2=consumes(b2),</span> <span class="pre">value3=lists(consumes(b3)))</span></code></p>
<p>will consume a value from Bundle <code class="docutils literal notranslate"><span class="pre">b2</span></code> and several values from Bundle
<code class="docutils literal notranslate"><span class="pre">b3</span></code> to populate <code class="docutils literal notranslate"><span class="pre">value2</span></code> and <code class="docutils literal notranslate"><span class="pre">value3</span></code> each time it is executed.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.stateful.multiple">
<code class="sig-prename descclassname">hypothesis.stateful.</code><code class="sig-name descname">multiple</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/stateful.html#multiple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.stateful.multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can be used to pass multiple results to the target(s) of
a rule. Just use <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">multiple(result1,</span> <span class="pre">result2,</span> <span class="pre">...)</span></code> in your rule.</p>
<p>It is also possible to use <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">multiple()</span></code> with no arguments in
order to end a rule without passing any result.</p>
</dd></dl>

</div>
<div class="section" id="initializes">
<h2>Initializes<a class="headerlink" href="#initializes" title="Permalink to this headline">¶</a></h2>
<p>Initializes are a special case of rules that are guaranteed to be run at most
once at the beginning of a run (i.e. before any normal rule is called).
Note if multiple initialize rules are defined, they may be called in any order,
and that order will vary from run to run.</p>
<p>Initializes are typically useful to populate bundles:</p>
<dl class="function">
<dt id="hypothesis.stateful.initialize">
<code class="sig-prename descclassname">hypothesis.stateful.</code><code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param">targets=()</em>, <em class="sig-param">target=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/stateful.html#initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.stateful.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for RuleBasedStateMachine.</p>
<p>An initialize decorator behaves like a rule, but the decorated
method is called at most once in a run. All initialize decorated
methods will be called before any rule decorated methods, in an
arbitrary order.</p>
</dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">hypothesis.strategies</span> <span class="kn">as</span> <span class="nn">st</span>
<span class="kn">from</span> <span class="nn">hypothesis.stateful</span> <span class="kn">import</span> <span class="n">RuleBasedStateMachine</span><span class="p">,</span> <span class="n">Bundle</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">initialize</span>

<span class="n">name_strategy</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">NumberModifier</span><span class="p">(</span><span class="n">RuleBasedStateMachine</span><span class="p">):</span>

    <span class="n">folders</span> <span class="o">=</span> <span class="n">Bundle</span><span class="p">(</span><span class="s1">&#39;folders&#39;</span><span class="p">)</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">Bundle</span><span class="p">(</span><span class="s1">&#39;files&#39;</span><span class="p">)</span>

    <span class="nd">@initialize</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">folders</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">init_folders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;/&#39;</span>

    <span class="nd">@rule</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">folders</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name_strategy</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">create_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="nd">@rule</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">files</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name_strategy</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">create_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="preconditions">
<h2>Preconditions<a class="headerlink" href="#preconditions" title="Permalink to this headline">¶</a></h2>
<p>While it’s possible to use <a class="reference internal" href="details.html#hypothesis.assume" title="hypothesis.assume"><code class="xref py py-func docutils literal notranslate"><span class="pre">assume()</span></code></a> in RuleBasedStateMachine rules, if you
use it in only a few rules you can quickly run into a situation where few or
none of your rules pass their assumptions. Thus, Hypothesis provides a
<a class="reference internal" href="#hypothesis.stateful.precondition" title="hypothesis.stateful.precondition"><code class="xref py py-func docutils literal notranslate"><span class="pre">precondition()</span></code></a> decorator to avoid this problem. The <a class="reference internal" href="#hypothesis.stateful.precondition" title="hypothesis.stateful.precondition"><code class="xref py py-func docutils literal notranslate"><span class="pre">precondition()</span></code></a>
decorator is used on <code class="docutils literal notranslate"><span class="pre">rule</span></code>-decorated functions, and must be given a function
that returns True or False based on the RuleBasedStateMachine instance.</p>
<dl class="function">
<dt id="hypothesis.stateful.precondition">
<code class="sig-prename descclassname">hypothesis.stateful.</code><code class="sig-name descname">precondition</code><span class="sig-paren">(</span><em class="sig-param">precond</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/stateful.html#precondition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.stateful.precondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to apply a precondition for rules in a RuleBasedStateMachine.
Specifies a precondition for a rule to be considered as a valid step in the
state machine. The given function will be called with the instance of
RuleBasedStateMachine and should return True or False. Usually it will need
to look at attributes on that instance.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestMachine</span><span class="p">(</span><span class="n">RuleBasedStateMachine</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="nd">@precondition</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nd">@rule</span><span class="p">(</span><span class="n">numerator</span><span class="o">=</span><span class="n">integers</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">divide_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numerator</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
<p>This is better than using assume in your rule since more valid rules
should be able to be run.</p>
</dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">hypothesis.stateful</span> <span class="kn">import</span> <span class="n">RuleBasedStateMachine</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">precondition</span>

<span class="k">class</span> <span class="nc">NumberModifier</span><span class="p">(</span><span class="n">RuleBasedStateMachine</span><span class="p">):</span>

    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@rule</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nd">@precondition</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nd">@rule</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">divide_with_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span>
</pre></div>
</div>
<p>By using <a class="reference internal" href="#hypothesis.stateful.precondition" title="hypothesis.stateful.precondition"><code class="xref py py-func docutils literal notranslate"><span class="pre">precondition()</span></code></a> here instead of <a class="reference internal" href="details.html#hypothesis.assume" title="hypothesis.assume"><code class="xref py py-func docutils literal notranslate"><span class="pre">assume()</span></code></a>, Hypothesis can filter the
inapplicable rules before running them. This makes it much more likely that a
useful sequence of steps will be generated.</p>
<p>Note that currently preconditions can’t access bundles; if you need to use
preconditions, you should store relevant data on the instance instead.</p>
</div>
<div class="section" id="invariants">
<h2>Invariants<a class="headerlink" href="#invariants" title="Permalink to this headline">¶</a></h2>
<p>Often there are invariants that you want to ensure are met after every step in
a process.  It would be possible to add these as rules that are run, but they
would be run zero or multiple times between other rules. Hypothesis provides a
decorator that marks a function to be run after every step.</p>
<dl class="function">
<dt id="hypothesis.stateful.invariant">
<code class="sig-prename descclassname">hypothesis.stateful.</code><code class="sig-name descname">invariant</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/stateful.html#invariant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.stateful.invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to apply an invariant for rules in a RuleBasedStateMachine.
The decorated function will be run after every rule and can raise an
exception to indicate failed invariants.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestMachine</span><span class="p">(</span><span class="n">RuleBasedStateMachine</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="nd">@invariant</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">is_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">hypothesis.stateful</span> <span class="kn">import</span> <span class="n">RuleBasedStateMachine</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">invariant</span>

<span class="k">class</span> <span class="nc">NumberModifier</span><span class="p">(</span><span class="n">RuleBasedStateMachine</span><span class="p">):</span>

    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@rule</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">add_two</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nd">@invariant</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">divide_with_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

<span class="n">NumberTest</span> <span class="o">=</span> <span class="n">NumberModifier</span><span class="o">.</span><span class="n">TestCase</span>
</pre></div>
</div>
<p>Invariants can also have <a class="reference internal" href="#hypothesis.stateful.precondition" title="hypothesis.stateful.precondition"><code class="xref py py-func docutils literal notranslate"><span class="pre">precondition()</span></code></a>s applied to them, in which case
they will only be run if the precondition function returns true.</p>
<p>Note that currently invariants can’t access bundles; if you need to use
invariants, you should store relevant data on the instance instead.</p>
</div>
<div class="section" id="generic-state-machines">
<h2>Generic state machines<a class="headerlink" href="#generic-state-machines" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">GenericStateMachine</span></code> is deprecated and will be removed in a future version.</p>
</div>
<dl class="class">
<dt id="hypothesis.stateful.GenericStateMachine">
<em class="property">class </em><code class="sig-prename descclassname">hypothesis.stateful.</code><code class="sig-name descname">GenericStateMachine</code><a class="reference internal" href="_modules/hypothesis/stateful.html#GenericStateMachine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.stateful.GenericStateMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>A GenericStateMachine is a deprecated approach to stateful testing.</p>
<p>In earlier versions of Hypothesis, you would define <code class="docutils literal notranslate"><span class="pre">steps</span></code>,
<code class="docutils literal notranslate"><span class="pre">execute_step</span></code>, <code class="docutils literal notranslate"><span class="pre">teardown</span></code>, and <code class="docutils literal notranslate"><span class="pre">check_invariants</span></code> methods;
and the engine would then run something like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@given</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_the_stateful_thing</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">MyStatemachineSubclass</span><span class="p">()</span>
    <span class="n">x</span><span class="o">.</span><span class="n">check_invariants</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">steps</span><span class="p">())</span>
            <span class="n">x</span><span class="o">.</span><span class="n">execute_step</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">check_invariants</span><span class="p">()</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">x</span><span class="o">.</span><span class="n">teardown</span><span class="p">()</span>
</pre></div>
</div>
<p>We now recommend using rule-based stateful testing instead wherever
possible.  If your test is better expressed in the above format than
as a rule-based state machine, we suggest “unrolling” your method
definitions into a simple test function with the above control flow.</p>
</dd></dl>

</div>
<div class="section" id="more-fine-grained-control">
<h2>More fine grained control<a class="headerlink" href="#more-fine-grained-control" title="Permalink to this headline">¶</a></h2>
<p>If you want to bypass the TestCase infrastructure you can invoke these
manually. The stateful module exposes the function <code class="docutils literal notranslate"><span class="pre">run_state_machine_as_test</span></code>,
which takes an arbitrary function returning a RuleBasedStateMachine and an
optional settings parameter and does the same as the class based runTest
provided.</p>
<p>This is not recommended as it bypasses some important internal functions,
including reporting of statistics such as runtimes and <a class="reference internal" href="details.html#hypothesis.event" title="hypothesis.event"><code class="xref py py-func docutils literal notranslate"><span class="pre">event()</span></code></a>
calls.  It was originally added to support custom <code class="docutils literal notranslate"><span class="pre">__init__</span></code> methods, but
you can now use <a class="reference internal" href="#hypothesis.stateful.initialize" title="hypothesis.stateful.initialize"><code class="xref py py-func docutils literal notranslate"><span class="pre">initialize()</span></code></a> rules instead.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="supported.html" class="btn btn-neutral float-right" title="Compatibility" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="database.html" class="btn btn-neutral float-left" title="The Hypothesis Example Database" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2019, David R. MacIver

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>