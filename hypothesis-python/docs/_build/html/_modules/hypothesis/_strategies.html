

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hypothesis._strategies &mdash; Hypothesis 4.28.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Hypothesis
          

          
          </a>

          
            
            
              <div class="version">
                4.28.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick start guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../details.html">Details and advanced features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../settings.html">Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">What you can generate and how</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extras.html">First-party extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../django.html">Hypothesis for Django users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../numpy.html">Hypothesis for the Scientific Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../healthchecks.html">Health checks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../database.html">The Hypothesis Example Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stateful.html">Stateful testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../supported.html">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Some more examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manifesto.html">The Purpose of Hypothesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../endorsements.html">Testimonials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Open Source Projects using Hypothesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../strategies.html">Projects extending Hypothesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Ongoing Hypothesis Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support.html">Help and Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../packaging.html">Packaging Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reproducing.html">Reproducing Failures</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Hypothesis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>hypothesis._strategies</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hypothesis._strategies</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Hypothesis, which may be found at</span>
<span class="c1"># https://github.com/HypothesisWorks/hypothesis/</span>
<span class="c1">#</span>
<span class="c1"># Most of this work is copyright (C) 2013-2019 David R. MacIver</span>
<span class="c1"># (david@drmaciver.com), but it contains contributions by others. See</span>
<span class="c1"># CONTRIBUTING.rst for a full list of people who may hold copyright, and</span>
<span class="c1"># consult the git log if you need to determine who owns an individual</span>
<span class="c1"># contribution.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="c1">#</span>
<span class="c1"># END HEADER</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">localcontext</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">Fraction</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">isclass</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="k">import</span> <span class="n">UUID</span>

<span class="kn">import</span> <span class="nn">attr</span>

<span class="kn">from</span> <span class="nn">hypothesis._settings</span> <span class="k">import</span> <span class="n">note_deprecation</span>
<span class="kn">from</span> <span class="nn">hypothesis.control</span> <span class="k">import</span> <span class="n">cleanup</span><span class="p">,</span> <span class="n">note</span><span class="p">,</span> <span class="n">reject</span>
<span class="kn">from</span> <span class="nn">hypothesis.errors</span> <span class="k">import</span> <span class="n">InvalidArgument</span><span class="p">,</span> <span class="n">ResolutionFailed</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.cache</span> <span class="k">import</span> <span class="n">LRUReusedCache</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.cathetus</span> <span class="k">import</span> <span class="n">cathetus</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.charmap</span> <span class="k">import</span> <span class="n">as_general_categories</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.compat</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ceil</span><span class="p">,</span>
    <span class="n">floor</span><span class="p">,</span>
    <span class="n">gcd</span><span class="p">,</span>
    <span class="n">get_type_hints</span><span class="p">,</span>
    <span class="n">getfullargspec</span><span class="p">,</span>
    <span class="n">hrange</span><span class="p">,</span>
    <span class="n">implements_iterator</span><span class="p">,</span>
    <span class="n">string_types</span><span class="p">,</span>
    <span class="n">typing_root_type</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.conjecture.utils</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">calc_label_from_cls</span><span class="p">,</span>
    <span class="n">check_sample</span><span class="p">,</span>
    <span class="n">integer_range</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.entropy</span> <span class="k">import</span> <span class="n">get_seeder_and_restorer</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.floats</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">count_between_floats</span><span class="p">,</span>
    <span class="n">float_of</span><span class="p">,</span>
    <span class="n">float_to_int</span><span class="p">,</span>
    <span class="n">int_to_float</span><span class="p">,</span>
    <span class="n">is_negative</span><span class="p">,</span>
    <span class="n">next_down</span><span class="p">,</span>
    <span class="n">next_up</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.reflection</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">define_function_signature</span><span class="p">,</span>
    <span class="n">is_typed_named_tuple</span><span class="p">,</span>
    <span class="n">nicerepr</span><span class="p">,</span>
    <span class="n">proxies</span><span class="p">,</span>
    <span class="n">required_args</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.internal.validation</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">check_type</span><span class="p">,</span>
    <span class="n">check_valid_bound</span><span class="p">,</span>
    <span class="n">check_valid_integer</span><span class="p">,</span>
    <span class="n">check_valid_interval</span><span class="p">,</span>
    <span class="n">check_valid_magnitude</span><span class="p">,</span>
    <span class="n">check_valid_size</span><span class="p">,</span>
    <span class="n">check_valid_sizes</span><span class="p">,</span>
    <span class="n">try_convert</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy</span> <span class="k">import</span> <span class="n">SearchStrategy</span><span class="p">,</span> <span class="n">check_strategy</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.collections</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">FixedKeysDictStrategy</span><span class="p">,</span>
    <span class="n">ListStrategy</span><span class="p">,</span>
    <span class="n">TupleStrategy</span><span class="p">,</span>
    <span class="n">UniqueListStrategy</span><span class="p">,</span>
    <span class="n">UniqueSampledListStrategy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.datetime</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">DateStrategy</span><span class="p">,</span>
    <span class="n">DatetimeStrategy</span><span class="p">,</span>
    <span class="n">TimedeltaStrategy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.deferred</span> <span class="k">import</span> <span class="n">DeferredStrategy</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.functions</span> <span class="k">import</span> <span class="n">FunctionStrategy</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.lazy</span> <span class="k">import</span> <span class="n">LazyStrategy</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.misc</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">BoolStrategy</span><span class="p">,</span>
    <span class="n">JustStrategy</span><span class="p">,</span>
    <span class="n">SampledFromStrategy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.numbers</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">BoundedIntStrategy</span><span class="p">,</span>
    <span class="n">FixedBoundedFloatStrategy</span><span class="p">,</span>
    <span class="n">FloatStrategy</span><span class="p">,</span>
    <span class="n">WideRangeIntStrategy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.recursive</span> <span class="k">import</span> <span class="n">RecursiveStrategy</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.shared</span> <span class="k">import</span> <span class="n">SharedStrategy</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.strategies</span> <span class="k">import</span> <span class="n">OneOfStrategy</span>
<span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.strings</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">BinaryStringStrategy</span><span class="p">,</span>
    <span class="n">FixedSizeBytes</span><span class="p">,</span>
    <span class="n">OneCharStringStrategy</span><span class="p">,</span>
    <span class="n">StringStrategy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hypothesis.types</span> <span class="k">import</span> <span class="n">RandomWithSeed</span>
<span class="kn">from</span> <span class="nn">hypothesis.utils.conventions</span> <span class="k">import</span> <span class="n">infer</span><span class="p">,</span> <span class="n">not_set</span>

<span class="n">typing</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Union[None, ModuleType]</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">typing_module</span>

    <span class="n">typing</span> <span class="o">=</span> <span class="n">typing_module</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">numpy</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">random</span>  <span class="c1"># noqa</span>
    <span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">ModuleType</span>  <span class="c1"># noqa</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Pattern</span>  <span class="c1"># noqa</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">overload</span>  <span class="c1"># noqa</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Text</span><span class="p">,</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">Optional</span>  <span class="c1"># noqa</span>

    <span class="kn">from</span> <span class="nn">hypothesis.utils.conventions</span> <span class="k">import</span> <span class="n">InferType</span>  <span class="c1"># noqa</span>
    <span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.strategies</span> <span class="k">import</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ex</span>  <span class="c1"># noqa</span>

    <span class="n">K</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">[</span><span class="s2">&quot;K&quot;</span><span class="p">],</span> <span class="n">TypeVar</span><span class="p">[</span><span class="s2">&quot;V&quot;</span><span class="p">]</span>
    <span class="c1"># See https://github.com/python/mypy/issues/3186 - numbers.Real is wrong!</span>
    <span class="n">Real</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">overload</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span>


<span class="n">_strategies</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">FloatKey</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">float_to_int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">FloatKey</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">convert_value</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FloatKey</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>


<span class="n">STRATEGY_CACHE</span> <span class="o">=</span> <span class="n">LRUReusedCache</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">cacheable</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="c1"># type: (T) -&gt; T</span>
    <span class="nd">@proxies</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cached_strategy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kwargs_cache_key</span> <span class="o">=</span> <span class="p">{(</span><span class="n">k</span><span class="p">,</span> <span class="n">convert_value</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">convert_value</span><span class="p">,</span> <span class="n">args</span><span class="p">)),</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">kwargs_cache_key</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="n">STRATEGY_CACHE</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">STRATEGY_CACHE</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">SearchStrategy</span><span class="p">)</span> <span class="ow">or</span> <span class="n">result</span><span class="o">.</span><span class="n">is_cacheable</span><span class="p">:</span>
                <span class="n">STRATEGY_CACHE</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="n">cached_strategy</span><span class="o">.</span><span class="n">__clear_cache</span> <span class="o">=</span> <span class="n">STRATEGY_CACHE</span><span class="o">.</span><span class="n">clear</span>
    <span class="k">return</span> <span class="n">cached_strategy</span>


<span class="k">def</span> <span class="nf">base_defines_strategy</span><span class="p">(</span><span class="n">force_reusable</span><span class="p">):</span>
    <span class="c1"># type: (bool) -&gt; Callable[[T], T]</span>
    <span class="sd">&quot;&quot;&quot;Returns a decorator for strategy functions.</span>

<span class="sd">    If force_reusable is True, the generated values are assumed to be</span>
<span class="sd">    reusable, i.e. immutable and safe to cache, across multiple test</span>
<span class="sd">    invocations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">strategy_definition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A decorator that registers the function as a strategy and makes it</span>
<span class="sd">        lazily evaluated.&quot;&quot;&quot;</span>
        <span class="n">_strategies</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">strategy_definition</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="nd">@proxies</span><span class="p">(</span><span class="n">strategy_definition</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">LazyStrategy</span><span class="p">(</span><span class="n">strategy_definition</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">force_reusable</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">force_has_reusable_values</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">has_reusable_values</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">accept</span><span class="o">.</span><span class="n">is_hypothesis_strategy_function</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">accept</span>

    <span class="k">return</span> <span class="n">decorator</span>


<span class="n">defines_strategy</span> <span class="o">=</span> <span class="n">base_defines_strategy</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">defines_strategy_with_reusable_values</span> <span class="o">=</span> <span class="n">base_defines_strategy</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Nothing</span><span class="p">(</span><span class="n">SearchStrategy</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">calc_is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recur</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">do_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># This method should never be called because draw() will mark the</span>
        <span class="c1"># data as invalid immediately because is_empty is True.</span>
        <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">def</span> <span class="nf">calc_has_reusable_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recur</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;nothing()&quot;</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">flatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="n">NOTHING</span> <span class="o">=</span> <span class="n">Nothing</span><span class="p">()</span>


<div class="viewcode-block" id="nothing"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.nothing">[docs]</a><span class="nd">@cacheable</span>
<span class="k">def</span> <span class="nf">nothing</span><span class="p">():</span>
    <span class="c1"># type: () -&gt; SearchStrategy</span>
    <span class="sd">&quot;&quot;&quot;This strategy never successfully draws a value and will always reject on</span>
<span class="sd">    an attempt to draw.</span>

<span class="sd">    Examples from this strategy do not shrink (because there are none).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">NOTHING</span></div>


<div class="viewcode-block" id="just"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.just">[docs]</a><span class="k">def</span> <span class="nf">just</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="c1"># type: (T) -&gt; SearchStrategy[T]</span>
    <span class="sd">&quot;&quot;&quot;Return a strategy which only generates ``value``.</span>

<span class="sd">    Note: ``value`` is not copied. Be wary of using mutable values.</span>

<span class="sd">    If ``value`` is the result of a callable, you can use</span>
<span class="sd">    :func:`builds(callable) &lt;hypothesis.strategies.builds&gt;` instead</span>
<span class="sd">    of ``just(callable())`` to get a fresh value each time.</span>

<span class="sd">    Examples from this strategy do not shrink (because there is only one).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">JustStrategy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="none"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.none">[docs]</a><span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">none</span><span class="p">():</span>
    <span class="c1"># type: () -&gt; SearchStrategy[None]</span>
    <span class="sd">&quot;&quot;&quot;Return a strategy which only generates None.</span>

<span class="sd">    Examples from this strategy do not shrink (because there is only</span>
<span class="sd">    one).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">just</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">one_of</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># type: (Sequence[SearchStrategy[Any]]) -&gt; SearchStrategy[Any]</span>
    <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">one_of</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># type: (SearchStrategy[Any]) -&gt; SearchStrategy[Any]</span>
    <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>


<div class="viewcode-block" id="one_of"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.one_of">[docs]</a><span class="k">def</span> <span class="nf">one_of</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Mypy workaround alert:  Any is too loose above; the return paramater</span>
    <span class="c1"># should be the union of the input parameters.  Unfortunately, Mypy &lt;=0.600</span>
    <span class="c1"># raises errors due to incompatible inputs instead.  See #1270 for links.</span>
    <span class="c1"># v0.610 doesn&#39;t error; it gets inference wrong for 2+ arguments instead.</span>
    <span class="sd">&quot;&quot;&quot;Return a strategy which generates values from any of the argument</span>
<span class="sd">    strategies.</span>

<span class="sd">    This may be called with one iterable argument instead of multiple</span>
<span class="sd">    strategy arguments, in which case ``one_of(x)`` and ``one_of(*x)`` are</span>
<span class="sd">    equivalent.</span>

<span class="sd">    Examples from this strategy will generally shrink to ones that come from</span>
<span class="sd">    strategies earlier in the list, then shrink according to behaviour of the</span>
<span class="sd">    strategy that produced them. In order to get good shrinking behaviour,</span>
<span class="sd">    try to put simpler strategies first. e.g. ``one_of(none(), text())`` is</span>
<span class="sd">    better than ``one_of(text(), none())``.</span>

<span class="sd">    This is especially important when using recursive strategies. e.g.</span>
<span class="sd">    ``x = st.deferred(lambda: st.none() | st.tuples(x, x))`` will shrink well,</span>
<span class="sd">    but ``x = st.deferred(lambda: st.tuples(x, x) | st.none())`` will shrink</span>
<span class="sd">    very badly indeed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SearchStrategy</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">OneOfStrategy</span><span class="p">(</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="integers"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.integers">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># type: (Real, Real) -&gt; SearchStrategy[int]</span>
    <span class="sd">&quot;&quot;&quot;Returns a strategy which generates integers; in Python 2 these may be</span>
<span class="sd">    ints or longs.</span>

<span class="sd">    If min_value is not None then all values will be &gt;= min_value. If</span>
<span class="sd">    max_value is not None then all values will be &lt;= max_value</span>

<span class="sd">    Examples from this strategy will shrink towards zero, and negative values</span>
<span class="sd">    will also shrink towards positive (i.e. -n may be replaced by +n).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">check_valid_bound</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">)</span>
    <span class="n">check_valid_bound</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>

    <span class="n">min_int_value</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ceil</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span>
    <span class="n">max_int_value</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">floor</span><span class="p">(</span><span class="n">max_value</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">min_value</span> <span class="o">!=</span> <span class="n">min_int_value</span><span class="p">:</span>
        <span class="n">note_deprecation</span><span class="p">(</span>
            <span class="s2">&quot;min_value=</span><span class="si">%r</span><span class="s2"> of type </span><span class="si">%r</span><span class="s2"> cannot be exactly represented as an &quot;</span>
            <span class="s2">&quot;integer, which will be an error in a future version.  &quot;</span>
            <span class="s2">&quot;Use </span><span class="si">%r</span><span class="s2"> instead.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">min_value</span><span class="p">),</span> <span class="n">min_int_value</span><span class="p">),</span>
            <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2018-10-10&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">max_value</span> <span class="o">!=</span> <span class="n">max_int_value</span><span class="p">:</span>
        <span class="n">note_deprecation</span><span class="p">(</span>
            <span class="s2">&quot;max_value=</span><span class="si">%r</span><span class="s2"> of type </span><span class="si">%r</span><span class="s2"> cannot be exactly represented as an &quot;</span>
            <span class="s2">&quot;integer, which will be an error in a future version.  &quot;</span>
            <span class="s2">&quot;Use </span><span class="si">%r</span><span class="s2"> instead.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">max_value</span><span class="p">),</span> <span class="n">max_int_value</span><span class="p">),</span>
            <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2018-10-10&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">min_int_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">max_int_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">min_int_value</span> <span class="o">&gt;</span> <span class="n">max_int_value</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;No integers between min_value=</span><span class="si">%r</span><span class="s2"> and &quot;</span>
            <span class="s2">&quot;max_value=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">min_int_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_int_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">WideRangeIntStrategy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_int_value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">WideRangeIntStrategy</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">max_int_value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">WideRangeIntStrategy</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">max_int_value</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_int_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_int_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">WideRangeIntStrategy</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">min_int_value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">WideRangeIntStrategy</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">min_int_value</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">min_int_value</span> <span class="o">&lt;=</span> <span class="n">max_int_value</span>
            <span class="k">if</span> <span class="n">min_int_value</span> <span class="o">==</span> <span class="n">max_int_value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">just</span><span class="p">(</span><span class="n">min_int_value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">min_int_value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BoundedIntStrategy</span><span class="p">(</span><span class="n">min_int_value</span><span class="p">,</span> <span class="n">max_int_value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">max_int_value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BoundedIntStrategy</span><span class="p">(</span><span class="o">-</span><span class="n">max_int_value</span><span class="p">,</span> <span class="o">-</span><span class="n">min_int_value</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="o">-</span><span class="n">t</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">max_int_value</span><span class="p">)</span> <span class="o">|</span> <span class="n">integers</span><span class="p">(</span>
                    <span class="n">min_value</span><span class="o">=</span><span class="n">min_int_value</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="booleans"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.booleans">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">booleans</span><span class="p">():</span>
    <span class="c1"># type: () -&gt; SearchStrategy[bool]</span>
    <span class="sd">&quot;&quot;&quot;Returns a strategy which generates instances of :class:`python:bool`.</span>

<span class="sd">    Examples from this strategy will shrink towards False (i.e.</span>
<span class="sd">    shrinking will try to replace True with False where possible).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">BoolStrategy</span><span class="p">()</span></div>


<div class="viewcode-block" id="floats"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.floats">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">floats</span><span class="p">(</span>
    <span class="n">min_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Real</span>
    <span class="n">max_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Real</span>
    <span class="n">allow_nan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: bool</span>
    <span class="n">allow_infinity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: bool</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">exclude_min</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># type: bool</span>
    <span class="n">exclude_max</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># type: bool</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[float]</span>
    <span class="sd">&quot;&quot;&quot;Returns a strategy which generates floats.</span>

<span class="sd">    - If min_value is not None, all values will be &gt;= min_value.</span>
<span class="sd">    - If max_value is not None, all values will be &lt;= max_value.</span>
<span class="sd">    - If min_value or max_value is not None, it is an error to enable</span>
<span class="sd">      allow_nan.</span>
<span class="sd">    - If both min_value and max_value are not None, it is an error to enable</span>
<span class="sd">      allow_infinity.</span>

<span class="sd">    Where not explicitly ruled out by the bounds, all of infinity, -infinity</span>
<span class="sd">    and NaN are possible values generated by this strategy.</span>

<span class="sd">    The width argument specifies the maximum number of bits of precision</span>
<span class="sd">    required to represent the generated float. Valid values are 16, 32, or 64.</span>
<span class="sd">    Passing ``width=32`` will still use the builtin 64-bit ``float`` class,</span>
<span class="sd">    but always for values which can be exactly represented as a 32-bit float.</span>
<span class="sd">    Half-precision floats (``width=16``) are only supported on Python 3.6, or</span>
<span class="sd">    if :pypi:`Numpy` is installed.</span>

<span class="sd">    The exclude_min and exclude_max argument can be used to generate numbers</span>
<span class="sd">    from open or half-open intervals, by excluding the respective endpoints.</span>
<span class="sd">    Attempting to exclude an endpoint which is None will raise an error;</span>
<span class="sd">    use ``allow_infinity=False`` to generate finite floats.  You can however</span>
<span class="sd">    use e.g. ``min_value=float(&quot;-inf&quot;), exclude_min=True`` to exclude only</span>
<span class="sd">    one infinite endpoint.</span>

<span class="sd">    Examples from this strategy have a complicated and hard to explain</span>
<span class="sd">    shrinking behaviour, but it tries to improve &quot;human readability&quot;. Finite</span>
<span class="sd">    numbers will be preferred to infinity and infinity will be preferred to</span>
<span class="sd">    NaN.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_type</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">exclude_min</span><span class="p">,</span> <span class="s2">&quot;exclude_min&quot;</span><span class="p">)</span>
    <span class="n">check_type</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">exclude_max</span><span class="p">,</span> <span class="s2">&quot;exclude_max&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">allow_nan</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">allow_nan</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;Cannot have allow_nan=</span><span class="si">%r</span><span class="s2">, with min_value or max_value&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">allow_nan</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">width</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;Got width=</span><span class="si">%r</span><span class="s2">, but the only valid values are the integers 16, &quot;</span>
            <span class="s2">&quot;32, and 64.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">width</span><span class="p">,)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">16</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="ow">and</span> <span class="n">numpy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>  <span class="c1"># pragma: no cover</span>
            <span class="s2">&quot;width=16 requires either Numpy, or Python &gt;= 3.6&quot;</span>
        <span class="p">)</span>

    <span class="n">check_valid_bound</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">)</span>
    <span class="n">check_valid_bound</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>

    <span class="n">min_arg</span><span class="p">,</span> <span class="n">max_arg</span> <span class="o">=</span> <span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span>
    <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="n">float_of</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="n">float_of</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">min_value</span> <span class="o">!=</span> <span class="n">min_arg</span><span class="p">:</span>
        <span class="n">note_deprecation</span><span class="p">(</span>
            <span class="s2">&quot;min_value=</span><span class="si">%r</span><span class="s2"> cannot be exactly represented as a float of width &quot;</span>
            <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, which will be an error in a future version. Use min_value=</span><span class="si">%r</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;instead.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">min_arg</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">min_value</span><span class="p">),</span>
            <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2018-10-10&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">max_value</span> <span class="o">!=</span> <span class="n">max_arg</span><span class="p">:</span>
        <span class="n">note_deprecation</span><span class="p">(</span>
            <span class="s2">&quot;max_value=</span><span class="si">%r</span><span class="s2"> cannot be exactly represented as a float of width &quot;</span>
            <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, which will be an error in a future version. Use max_value=</span><span class="si">%r</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;instead&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">max_arg</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">max_value</span><span class="p">),</span>
            <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2018-10-10&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">exclude_min</span> <span class="ow">and</span> <span class="p">(</span><span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_value</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;Cannot exclude min_value=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">min_value</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">exclude_max</span> <span class="ow">and</span> <span class="p">(</span><span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_value</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;Cannot exclude max_value=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">max_value</span><span class="p">,))</span>

    <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">exclude_min</span> <span class="ow">or</span> <span class="p">(</span><span class="n">min_arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_value</span> <span class="o">&lt;</span> <span class="n">min_arg</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="n">next_up</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">min_value</span> <span class="o">&gt;</span> <span class="n">min_arg</span> <span class="ow">or</span> <span class="n">min_value</span> <span class="o">==</span> <span class="n">min_arg</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># type: ignore</span>
    <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">exclude_max</span> <span class="ow">or</span> <span class="p">(</span><span class="n">max_arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_value</span> <span class="o">&gt;</span> <span class="n">max_arg</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="n">next_down</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">max_value</span> <span class="o">&lt;</span> <span class="n">max_arg</span> <span class="ow">or</span> <span class="n">max_value</span> <span class="o">==</span> <span class="n">max_arg</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># type: ignore</span>

    <span class="k">if</span> <span class="n">min_value</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;-inf&quot;</span><span class="p">):</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">max_value</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">bad_zero_bounds</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">min_value</span> <span class="o">==</span> <span class="n">max_value</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="ow">and</span> <span class="n">is_negative</span><span class="p">(</span><span class="n">max_value</span><span class="p">)</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_negative</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">min_value</span> <span class="o">&gt;</span> <span class="n">max_value</span> <span class="ow">or</span> <span class="n">bad_zero_bounds</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="c1"># This is a custom alternative to check_valid_interval, because we want</span>
        <span class="c1"># to include the bit-width and exclusion information in the message.</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;There are no </span><span class="si">%s</span><span class="s2">-bit floating-point values between min_value=</span><span class="si">%r</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;and max_value=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">min_arg</span><span class="p">,</span> <span class="n">max_arg</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">exclude_min</span> <span class="ow">or</span> <span class="n">exclude_max</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;, exclude_min=</span><span class="si">%r</span><span class="s2"> and exclude_max=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">exclude_min</span><span class="p">,</span> <span class="n">exclude_max</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bad_zero_bounds</span><span class="p">:</span>
            <span class="n">note_deprecation</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2019-03-19&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">allow_infinity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">allow_infinity</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">allow_infinity</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;Cannot have allow_infinity=</span><span class="si">%r</span><span class="s2">, with both min_value and &quot;</span>
                <span class="s2">&quot;max_value&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">allow_infinity</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="n">min_value</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;allow_infinity=False excludes min_value=inf&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">max_value</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;allow_infinity=False excludes max_value=-inf&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">FloatStrategy</span><span class="p">(</span>
            <span class="n">allow_infinity</span><span class="o">=</span><span class="n">allow_infinity</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span>
        <span class="p">)</span>  <span class="c1"># type: SearchStrategy[float]</span>
    <span class="k">elif</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">min_value</span> <span class="o">==</span> <span class="n">max_value</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">just</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_negative</span><span class="p">(</span><span class="n">min_value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_negative</span><span class="p">(</span><span class="n">max_value</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">min_value</span><span class="o">=-</span><span class="n">max_value</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=-</span><span class="n">min_value</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">neg</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">max_value</span><span class="p">)</span> <span class="o">|</span> <span class="n">floats</span><span class="p">(</span>
                    <span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=-</span><span class="n">min_value</span>
                <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">count_between_floats</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">FixedBoundedFloatStrategy</span><span class="p">(</span>
                <span class="n">lower_bound</span><span class="o">=</span><span class="n">min_value</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="n">max_value</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ub_int</span> <span class="o">=</span> <span class="n">float_to_int</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
            <span class="n">lb_int</span> <span class="o">=</span> <span class="n">float_to_int</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">lb_int</span> <span class="o">&lt;=</span> <span class="n">ub_int</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="n">lb_int</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">ub_int</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">int_to_float</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">allow_infinity</span><span class="o">=</span><span class="n">allow_infinity</span><span class="p">)</span> <span class="o">|</span> <span class="n">floats</span><span class="p">(</span>
                <span class="n">min_value</span><span class="o">=</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=-</span><span class="mf">0.0</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">allow_infinity</span><span class="o">=</span><span class="n">allow_infinity</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">min_value</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_infinity</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">min_value</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_negative</span><span class="p">(</span><span class="n">min_value</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">max_value</span><span class="p">)</span> <span class="o">|</span> <span class="n">floats</span><span class="p">(</span>
                <span class="n">max_value</span><span class="o">=-</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">allow_infinity</span><span class="o">=</span><span class="n">allow_infinity</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">allow_infinity</span><span class="o">=</span><span class="n">allow_infinity</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">max_value</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_infinity</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">is_negative</span><span class="p">(</span><span class="n">max_value</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">is_negative</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">downcast</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">float_of</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
                <span class="n">reject</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">downcast</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="tuples"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.tuples">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">tuples</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># type: (*SearchStrategy) -&gt; SearchStrategy[tuple]</span>
    <span class="sd">&quot;&quot;&quot;Return a strategy which generates a tuple of the same length as args by</span>
<span class="sd">    generating the value at index i from args[i].</span>

<span class="sd">    e.g. tuples(integers(), integers()) would generate a tuple of length</span>
<span class="sd">    two with both values an integer.</span>

<span class="sd">    Examples from this strategy shrink by shrinking their component parts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">check_strategy</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">TupleStrategy</span><span class="p">(</span><span class="n">args</span><span class="p">)</span></div>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">sampled_from</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="c1"># type: (Sequence[T]) -&gt; SearchStrategy[T]</span>
    <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">sampled_from</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="c1"># type: (Type[enum.Enum]) -&gt; SearchStrategy[Any]</span>
    <span class="c1"># `SearchStrategy[Enum]` is unreliable due to metaclass issues.</span>
    <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>


<div class="viewcode-block" id="sampled_from"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.sampled_from">[docs]</a><span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">sampled_from</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a strategy which generates any value present in ``elements``.</span>

<span class="sd">    Note that as with :func:`~hypothesis.strategies.just`, values will not be</span>
<span class="sd">    copied and thus you should be careful of using mutable data.</span>

<span class="sd">    ``sampled_from`` supports ordered collections, as well as</span>
<span class="sd">    :class:`~python:enum.Enum` objects.  :class:`~python:enum.Flag` objects</span>
<span class="sd">    may also generate any combination of their members.</span>

<span class="sd">    Examples from this strategy shrink by replacing them with values earlier in</span>
<span class="sd">    the list. So e.g. sampled_from((10, 1)) will shrink by trying to replace</span>
<span class="sd">    1 values with 10, and sampled_from((1, 10)) will shrink by trying to</span>
<span class="sd">    replace 10 values with 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">check_sample</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="s2">&quot;sampled_from&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
        <span class="n">note_deprecation</span><span class="p">(</span>
            <span class="s2">&quot;sampled_from() with nothing to sample is deprecated and will be an &quot;</span>
            <span class="s2">&quot;error in a future version.  It currently returns `st.nothing()`, &quot;</span>
            <span class="s2">&quot;which if unexpected can make parts of a strategy silently vanish.&quot;</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2019-03-12&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">nothing</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">just</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="s2">&quot;Flag&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isclass</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Flag</span><span class="p">):</span>
        <span class="c1"># Combinations of enum.Flag members are also members.  We generate</span>
        <span class="c1"># these dynamically, because static allocation takes O(2^n) memory.</span>
        <span class="k">return</span> <span class="n">sets</span><span class="p">(</span><span class="n">sampled_from</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">SampledFromStrategy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="lists"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.lists">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">lists</span><span class="p">(</span>
    <span class="n">elements</span><span class="p">,</span>  <span class="c1"># type: SearchStrategy[Ex]</span>
    <span class="n">min_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">unique_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Union[Callable, Tuple[Callable, ...]]</span>
    <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># type: bool</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[List[Ex]]</span>
    <span class="sd">&quot;&quot;&quot;Returns a list containing values drawn from elements with length in the</span>
<span class="sd">    interval [min_size, max_size] (no bounds in that direction if these are</span>
<span class="sd">    None). If max_size is 0 then elements may be None and only the empty list</span>
<span class="sd">    will be drawn.</span>

<span class="sd">    If unique is True (or something that evaluates to True), we compare direct</span>
<span class="sd">    object equality, as if unique_by was ``lambda x: x``. This comparison only</span>
<span class="sd">    works for hashable types.</span>

<span class="sd">    If unique_by is not None it must be a callable or tuple of callables</span>
<span class="sd">    returning a hashable type when given a value drawn from elements. The</span>
<span class="sd">    resulting list will satisfy the condition that for ``i`` != ``j``,</span>
<span class="sd">    ``unique_by(result[i])`` != ``unique_by(result[j])``.</span>

<span class="sd">    If ``unique_by`` is a tuple of callables the uniqueness will be respective</span>
<span class="sd">    to each callable.</span>

<span class="sd">    For example, the following will produce two columns of integers with both</span>
<span class="sd">    columns being unique respectively.</span>
<span class="sd">    .. code-block:: pycon</span>

<span class="sd">        &gt;&gt;&gt; twoints = st.tuples(st.integers(), st.integers())</span>
<span class="sd">        &gt;&gt;&gt; st.lists(twoints, unique_by=(lambda x: x[0], lambda x: x[1]))</span>

<span class="sd">    Examples from this strategy shrink by trying to remove elements from the</span>
<span class="sd">    list, and by shrinking each individual element of the list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_valid_sizes</span><span class="p">(</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">)</span>
    <span class="n">check_strategy</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="s2">&quot;elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">unique_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;cannot specify both unique and unique_by &quot;</span>
                <span class="s2">&quot;(you probably only want to set unique_by)&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">unique_by</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">max_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builds</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unique_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">unique_by</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unique_by</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;unique_by=</span><span class="si">%r</span><span class="s2"> is not a callable or tuple of callables&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">unique_by</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">unique_by</span><span class="p">):</span>
            <span class="n">unique_by</span> <span class="o">=</span> <span class="p">(</span><span class="n">unique_by</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_by</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;unique_by is empty&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_by</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;unique_by[</span><span class="si">%i</span><span class="s2">]=</span><span class="si">%r</span><span class="s2"> is not a callable&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="c1"># Note that lazy strategies automatically unwrap when passed to a defines_strategy</span>
        <span class="c1"># function.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">SampledFromStrategy</span><span class="p">):</span>
            <span class="n">element_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">min_size</span> <span class="o">&gt;</span> <span class="n">element_count</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot create a collection of min_size=</span><span class="si">%r</span><span class="s2"> unique elements with &quot;</span>
                    <span class="s2">&quot;values drawn from only </span><span class="si">%d</span><span class="s2"> distinct elements&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">min_size</span><span class="p">,</span> <span class="n">element_count</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">max_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="n">element_count</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">element_count</span>

            <span class="k">return</span> <span class="n">UniqueSampledListStrategy</span><span class="p">(</span>
                <span class="n">elements</span><span class="o">=</span><span class="n">elements</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">unique_by</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">UniqueListStrategy</span><span class="p">(</span>
            <span class="n">elements</span><span class="o">=</span><span class="n">elements</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">unique_by</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">ListStrategy</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="sets"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.sets">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">sets</span><span class="p">(</span>
    <span class="n">elements</span><span class="p">,</span>  <span class="c1"># type: SearchStrategy[Ex]</span>
    <span class="n">min_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[Set[Ex]]</span>
    <span class="sd">&quot;&quot;&quot;This has the same behaviour as lists, but returns sets instead.</span>

<span class="sd">    Note that Hypothesis cannot tell if values are drawn from elements</span>
<span class="sd">    are hashable until running the test, so you can define a strategy</span>
<span class="sd">    for sets of an unhashable type but it will fail at test time.</span>

<span class="sd">    Examples from this strategy shrink by trying to remove elements from the</span>
<span class="sd">    set, and by shrinking each individual element of the set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">lists</span><span class="p">(</span>
        <span class="n">elements</span><span class="o">=</span><span class="n">elements</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span></div>


<div class="viewcode-block" id="frozensets"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.frozensets">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">frozensets</span><span class="p">(</span>
    <span class="n">elements</span><span class="p">,</span>  <span class="c1"># type: SearchStrategy[Ex]</span>
    <span class="n">min_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[FrozenSet[Ex]]</span>
    <span class="sd">&quot;&quot;&quot;This is identical to the sets function but instead returns</span>
<span class="sd">    frozensets.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">lists</span><span class="p">(</span>
        <span class="n">elements</span><span class="o">=</span><span class="n">elements</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">)</span></div>


<span class="nd">@implements_iterator</span>
<span class="k">class</span> <span class="nc">PrettyIter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;iter(</span><span class="si">{!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>


<div class="viewcode-block" id="iterables"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.iterables">[docs]</a><span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">iterables</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unique_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This has the same behaviour as lists, but returns iterables instead.</span>

<span class="sd">    Some iterables cannot be indexed (e.g. sets) and some do not have a</span>
<span class="sd">    fixed length (e.g. generators). This strategy produces iterators,</span>
<span class="sd">    which cannot be indexed and do not have a fixed length. This ensures</span>
<span class="sd">    that you do not accidentally depend on sequence behaviour.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">lists</span><span class="p">(</span>
        <span class="n">elements</span><span class="o">=</span><span class="n">elements</span><span class="p">,</span>
        <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span>
        <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span>
        <span class="n">unique_by</span><span class="o">=</span><span class="n">unique_by</span><span class="p">,</span>
        <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">PrettyIter</span><span class="p">)</span></div>


<div class="viewcode-block" id="fixed_dictionaries"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.fixed_dictionaries">[docs]</a><span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">fixed_dictionaries</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
    <span class="c1"># type: (Dict[T, SearchStrategy[Ex]]) -&gt; SearchStrategy[Dict[T, Ex]]</span>
    <span class="sd">&quot;&quot;&quot;Generates a dictionary of the same type as mapping with a fixed set of</span>
<span class="sd">    keys mapping to strategies. mapping must be a dict subclass.</span>

<span class="sd">    Generated values have all keys present in mapping, with the</span>
<span class="sd">    corresponding values drawn from mapping[key]. If mapping is an</span>
<span class="sd">    instance of OrderedDict the keys will also be in the same order,</span>
<span class="sd">    otherwise the order is arbitrary.</span>

<span class="sd">    Examples from this strategy shrink by shrinking each individual value in</span>
<span class="sd">    the generated dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_type</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="s2">&quot;mapping&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">check_strategy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FixedKeysDictStrategy</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span></div>


<div class="viewcode-block" id="dictionaries"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.dictionaries">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">dictionaries</span><span class="p">(</span>
    <span class="n">keys</span><span class="p">,</span>  <span class="c1"># type: SearchStrategy[Ex]</span>
    <span class="n">values</span><span class="p">,</span>  <span class="c1"># type: SearchStrategy[T]</span>
    <span class="n">dict_class</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span>  <span class="c1"># type: type</span>
    <span class="n">min_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[Dict[Ex, T]]</span>
    <span class="c1"># Describing the exact dict_class to Mypy drops the key and value types,</span>
    <span class="c1"># so we report Dict[K, V] instead of Mapping[Any, Any] for now.  Sorry!</span>
    <span class="sd">&quot;&quot;&quot;Generates dictionaries of type dict_class with keys drawn from the keys</span>
<span class="sd">    argument and values drawn from the values argument.</span>

<span class="sd">    The size parameters have the same interpretation as for lists.</span>

<span class="sd">    Examples from this strategy shrink by trying to remove keys from the</span>
<span class="sd">    generated dictionary, and by shrinking each generated key and value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_valid_sizes</span><span class="p">(</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fixed_dictionaries</span><span class="p">(</span><span class="n">dict_class</span><span class="p">())</span>
    <span class="n">check_strategy</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
    <span class="n">check_strategy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lists</span><span class="p">(</span>
        <span class="n">tuples</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">),</span>
        <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span>
        <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span>
        <span class="n">unique_by</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">dict_class</span><span class="p">)</span></div>


<div class="viewcode-block" id="characters"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.characters">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">characters</span><span class="p">(</span>
    <span class="n">whitelist_categories</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Sequence[Text]</span>
    <span class="n">blacklist_categories</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Sequence[Text]</span>
    <span class="n">blacklist_characters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Sequence[Text]</span>
    <span class="n">min_codepoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">max_codepoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">whitelist_characters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Sequence[Text]</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[Text]</span>
    <span class="sd">&quot;&quot;&quot;Generates unicode text type (unicode on python 2, str on python 3)</span>
<span class="sd">    characters following specified filtering rules.</span>

<span class="sd">    - When no filtering rules are specifed, any character can be produced.</span>
<span class="sd">    - If ``min_codepoint`` or ``max_codepoint`` is specifed, then only</span>
<span class="sd">      characters having a codepoint in that range will be produced.</span>
<span class="sd">    - If ``whitelist_categories`` is specified, then only characters from those</span>
<span class="sd">      Unicode categories will be produced. This is a further restriction,</span>
<span class="sd">      characters must also satisfy ``min_codepoint`` and ``max_codepoint``.</span>
<span class="sd">    - If ``blacklist_categories`` is specified, then any character from those</span>
<span class="sd">      categories will not be produced.  Any overlap between</span>
<span class="sd">      ``whitelist_categories`` and ``blacklist_categories`` will raise an</span>
<span class="sd">      exception, as each character can only belong to a single class.</span>
<span class="sd">    - If ``whitelist_characters`` is specified, then any additional characters</span>
<span class="sd">      in that list will also be produced.</span>
<span class="sd">    - If ``blacklist_characters`` is specified, then any characters in</span>
<span class="sd">      that list will be not be produced. Any overlap between</span>
<span class="sd">      ``whitelist_characters`` and ``blacklist_characters`` will raise an</span>
<span class="sd">      exception.</span>

<span class="sd">    The ``_codepoint`` arguments must be integers between zero and</span>
<span class="sd">    :obj:`python:sys.maxunicode`.  The ``_characters`` arguments must be</span>
<span class="sd">    collections of length-one unicode strings, such as a unicode string.</span>

<span class="sd">    The ``_categories`` arguments must be used to specify either the</span>
<span class="sd">    one-letter Unicode major category or the two-letter Unicode</span>
<span class="sd">    `general category`_.  For example, ``(&#39;Nd&#39;, &#39;Lu&#39;)`` signifies &quot;Number,</span>
<span class="sd">    decimal digit&quot; and &quot;Letter, uppercase&quot;.  A single letter (&#39;major category&#39;)</span>
<span class="sd">    can be given to match all corresponding categories, for example ``&#39;P&#39;``</span>
<span class="sd">    for characters in any punctuation category.</span>

<span class="sd">    .. _general category: https://wikipedia.org/wiki/Unicode_character_property</span>

<span class="sd">    Examples from this strategy shrink towards the codepoint for ``&#39;0&#39;``,</span>
<span class="sd">    or the first allowable codepoint after it if ``&#39;0&#39;`` is excluded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_valid_size</span><span class="p">(</span><span class="n">min_codepoint</span><span class="p">,</span> <span class="s2">&quot;min_codepoint&quot;</span><span class="p">)</span>
    <span class="n">check_valid_size</span><span class="p">(</span><span class="n">max_codepoint</span><span class="p">,</span> <span class="s2">&quot;max_codepoint&quot;</span><span class="p">)</span>
    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_codepoint</span><span class="p">,</span> <span class="n">max_codepoint</span><span class="p">,</span> <span class="s2">&quot;min_codepoint&quot;</span><span class="p">,</span> <span class="s2">&quot;max_codepoint&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">min_codepoint</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">max_codepoint</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">whitelist_categories</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">blacklist_categories</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">whitelist_characters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;Nothing is excluded by other arguments, so passing only &quot;</span>
            <span class="s2">&quot;whitelist_characters=</span><span class="si">%(chars)r</span><span class="s2"> would have no effect.  Also pass &quot;</span>
            <span class="s2">&quot;whitelist_categories=(), or use sampled_from(</span><span class="si">%(chars)r</span><span class="s2">) instead.&quot;</span>
            <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">chars</span><span class="o">=</span><span class="n">whitelist_characters</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">blacklist_characters</span> <span class="o">=</span> <span class="n">blacklist_characters</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
    <span class="n">whitelist_characters</span> <span class="o">=</span> <span class="n">whitelist_characters</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">blacklist_characters</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">whitelist_characters</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;Characters </span><span class="si">%r</span><span class="s2"> are present in both whitelist_characters=</span><span class="si">%r</span><span class="s2">, and &quot;</span>
            <span class="s2">&quot;blacklist_characters=</span><span class="si">%r</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">overlap</span><span class="p">),</span> <span class="n">whitelist_characters</span><span class="p">,</span> <span class="n">blacklist_characters</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">blacklist_categories</span> <span class="o">=</span> <span class="n">as_general_categories</span><span class="p">(</span>
        <span class="n">blacklist_categories</span><span class="p">,</span> <span class="s2">&quot;blacklist_categories&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">whitelist_categories</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">whitelist_categories</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">whitelist_characters</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;When whitelist_categories is an empty collection and there are &quot;</span>
            <span class="s2">&quot;no characters specified in whitelist_characters, nothing can &quot;</span>
            <span class="s2">&quot;be generated by the characters() strategy.&quot;</span>
        <span class="p">)</span>
    <span class="n">whitelist_categories</span> <span class="o">=</span> <span class="n">as_general_categories</span><span class="p">(</span>
        <span class="n">whitelist_categories</span><span class="p">,</span> <span class="s2">&quot;whitelist_categories&quot;</span>
    <span class="p">)</span>
    <span class="n">both_cats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">blacklist_categories</span> <span class="ow">or</span> <span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">whitelist_categories</span> <span class="ow">or</span> <span class="p">())</span>
    <span class="k">if</span> <span class="n">both_cats</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;Categories </span><span class="si">%r</span><span class="s2"> are present in both whitelist_categories=</span><span class="si">%r</span><span class="s2">, and &quot;</span>
            <span class="s2">&quot;blacklist_categories=</span><span class="si">%r</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">both_cats</span><span class="p">),</span> <span class="n">whitelist_categories</span><span class="p">,</span> <span class="n">blacklist_categories</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">OneCharStringStrategy</span><span class="p">(</span>
        <span class="n">whitelist_categories</span><span class="o">=</span><span class="n">whitelist_categories</span><span class="p">,</span>
        <span class="n">blacklist_categories</span><span class="o">=</span><span class="n">blacklist_categories</span><span class="p">,</span>
        <span class="n">blacklist_characters</span><span class="o">=</span><span class="n">blacklist_characters</span><span class="p">,</span>
        <span class="n">min_codepoint</span><span class="o">=</span><span class="n">min_codepoint</span><span class="p">,</span>
        <span class="n">max_codepoint</span><span class="o">=</span><span class="n">max_codepoint</span><span class="p">,</span>
        <span class="n">whitelist_characters</span><span class="o">=</span><span class="n">whitelist_characters</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="text"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.text">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">text</span><span class="p">(</span>
    <span class="n">alphabet</span><span class="o">=</span><span class="n">characters</span><span class="p">(</span>
        <span class="n">blacklist_categories</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Cs&quot;</span><span class="p">,)</span>
    <span class="p">),</span>  <span class="c1"># type: Union[Sequence[Text], SearchStrategy[Text]]</span>
    <span class="n">min_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># type: int</span>
    <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[Text]</span>
    <span class="sd">&quot;&quot;&quot;Generates values of a unicode text type (unicode on python 2, str on</span>
<span class="sd">    python 3) with values drawn from alphabet, which should be an iterable of</span>
<span class="sd">    length one strings or a strategy generating such strings.</span>

<span class="sd">    The default alphabet strategy can generate the full unicode range but</span>
<span class="sd">    excludes surrogate characters because they are invalid in the UTF-8</span>
<span class="sd">    encoding.  You can use :func:`~hypothesis.strategies.characters` without</span>
<span class="sd">    arguments to find surrogate-related bugs such as :bpo:`34454`.</span>

<span class="sd">    min_size and max_size have the usual interpretations.</span>
<span class="sd">    Note that Python measures string length by counting codepoints: U+00C5</span>
<span class="sd">    ``Å`` is a single character, while U+0041 U+030A ``Å`` is two - the ``A``,</span>
<span class="sd">    and a combining ring above.</span>

<span class="sd">    Examples from this strategy shrink towards shorter strings, and with the</span>
<span class="sd">    characters in the text shrinking as per the alphabet strategy.</span>
<span class="sd">    This strategy does not :func:`~python:unicodedata.normalize` examples,</span>
<span class="sd">    so generated strings may be in any or none of the &#39;normal forms&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_valid_sizes</span><span class="p">(</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">note_deprecation</span><span class="p">(</span>
            <span class="s2">&quot;alphabet=None is deprecated; just omit the argument&quot;</span><span class="p">,</span> <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2018-10-05&quot;</span>
        <span class="p">)</span>
        <span class="n">char_strategy</span> <span class="o">=</span> <span class="n">characters</span><span class="p">(</span><span class="n">blacklist_categories</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Cs&quot;</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">SearchStrategy</span><span class="p">):</span>
        <span class="n">char_strategy</span> <span class="o">=</span> <span class="n">alphabet</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">non_string</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">alphabet</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">non_string</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;The following elements in alphabet are not unicode &quot;</span>
                <span class="s2">&quot;strings:  </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">non_string</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="n">not_one_char</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">alphabet</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">not_one_char</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;The following elements in alphabet are not of length &quot;</span>
                <span class="s2">&quot;one, which leads to violation of size constraints:  </span><span class="si">%r</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">not_one_char</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="n">char_strategy</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">characters</span><span class="p">(</span><span class="n">whitelist_categories</span><span class="o">=</span><span class="p">(),</span> <span class="n">whitelist_characters</span><span class="o">=</span><span class="n">alphabet</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alphabet</span>
            <span class="k">else</span> <span class="n">nothing</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">max_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">char_strategy</span><span class="o">.</span><span class="n">is_empty</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">min_size</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">just</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">StringStrategy</span><span class="p">(</span><span class="n">lists</span><span class="p">(</span><span class="n">char_strategy</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">))</span></div>


<div class="viewcode-block" id="from_regex"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.from_regex">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">from_regex</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">fullmatch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># type: (Union[AnyStr, Pattern[AnyStr]], bool) -&gt; SearchStrategy[AnyStr]</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generates strings that contain a match for the given regex (i.e. ones</span>
<span class="sd">    for which :func:`python:re.search` will return a non-None result).</span>

<span class="sd">    ``regex`` may be a pattern or :func:`compiled regex &lt;python:re.compile&gt;`.</span>
<span class="sd">    Both byte-strings and unicode strings are supported, and will generate</span>
<span class="sd">    examples of the same type.</span>

<span class="sd">    You can use regex flags such as :obj:`python:re.IGNORECASE` or</span>
<span class="sd">    :obj:`python:re.DOTALL` to control generation. Flags can be passed either</span>
<span class="sd">    in compiled regex or inside the pattern with a ``(?iLmsux)`` group.</span>

<span class="sd">    Some regular expressions are only partly supported - the underlying</span>
<span class="sd">    strategy checks local matching and relies on filtering to resolve</span>
<span class="sd">    context-dependent expressions.  Using too many of these constructs may</span>
<span class="sd">    cause health-check errors as too many examples are filtered out. This</span>
<span class="sd">    mainly includes (positive or negative) lookahead and lookbehind groups.</span>

<span class="sd">    If you want the generated string to match the whole regex you should use</span>
<span class="sd">    boundary markers. So e.g. ``r&quot;\A.\Z&quot;`` will return a single character</span>
<span class="sd">    string, while ``&quot;.&quot;`` will return any string, and ``r&quot;\A.$&quot;`` will return</span>
<span class="sd">    a single character optionally followed by a ``&quot;\n&quot;``.</span>
<span class="sd">    Alternatively, passing ``fullmatch=True`` will ensure that the whole</span>
<span class="sd">    string is a match, as if you had used the ``\A`` and ``\Z`` markers.</span>

<span class="sd">    Examples from this strategy shrink towards shorter strings and lower</span>
<span class="sd">    character values, with exact behaviour that may depend on the pattern.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_type</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">fullmatch</span><span class="p">,</span> <span class="s2">&quot;fullmatch&quot;</span><span class="p">)</span>
    <span class="c1"># TODO: We would like to move this to the top level, but pending some major</span>
    <span class="c1"># refactoring it&#39;s hard to do without creating circular imports.</span>
    <span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.regex</span> <span class="k">import</span> <span class="n">regex_strategy</span>

    <span class="k">return</span> <span class="n">regex_strategy</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">fullmatch</span><span class="p">)</span></div>


<div class="viewcode-block" id="binary"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.binary">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">binary</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># type: (int, int) -&gt; SearchStrategy[bytes]</span>
    <span class="sd">&quot;&quot;&quot;Generates the appropriate binary type (str in python 2, bytes in python</span>
<span class="sd">    3).</span>

<span class="sd">    min_size and max_size have the usual interpretations.</span>

<span class="sd">    Examples from this strategy shrink towards smaller strings and lower byte</span>
<span class="sd">    values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_valid_sizes</span><span class="p">(</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_size</span> <span class="o">==</span> <span class="n">max_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FixedSizeBytes</span><span class="p">(</span><span class="n">min_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BinaryStringStrategy</span><span class="p">(</span>
        <span class="n">lists</span><span class="p">(</span>
            <span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">255</span><span class="p">),</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="randoms"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.randoms">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">randoms</span><span class="p">():</span>
    <span class="c1"># type: () -&gt; SearchStrategy[random.Random]</span>
    <span class="sd">&quot;&quot;&quot;Generates instances of ``random.Random``, tweaked to show the seed value</span>
<span class="sd">    in the repr for reproducibility.</span>

<span class="sd">    Examples from this strategy shrink to seeds closer to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">integers</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">RandomWithSeed</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">RandomSeeder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;RandomSeeder(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">,)</span>


<span class="k">class</span> <span class="nc">RandomModule</span><span class="p">(</span><span class="n">SearchStrategy</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">do_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">can_reproduce_example_from_repr</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">seed_all</span><span class="p">,</span> <span class="n">restore_all</span> <span class="o">=</span> <span class="n">get_seeder_and_restorer</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">seed_all</span><span class="p">()</span>
        <span class="n">cleanup</span><span class="p">(</span><span class="n">restore_all</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">RandomSeeder</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>


<div class="viewcode-block" id="random_module"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.random_module">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">random_module</span><span class="p">():</span>
    <span class="c1"># type: () -&gt; SearchStrategy[RandomSeeder]</span>
    <span class="sd">&quot;&quot;&quot;The Hypothesis engine handles PRNG state for the stdlib and Numpy random</span>
<span class="sd">    modules internally, always seeding them to zero and restoring the previous</span>
<span class="sd">    state after the test.</span>

<span class="sd">    If having a fixed seed would unacceptably weaken your tests, and you</span>
<span class="sd">    cannot use a ``random.Random`` instance provided by</span>
<span class="sd">    :func:`~hypothesis.strategies.randoms`, this strategy calls</span>
<span class="sd">    :func:`python:random.seed` with an arbitrary integer and passes you</span>
<span class="sd">    an opaque object whose repr displays the seed value for debugging.</span>
<span class="sd">    If ``numpy.random`` is available, that state is also managed.</span>

<span class="sd">    Examples from these strategy shrink to seeds closer to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">shared</span><span class="p">(</span><span class="n">RandomModule</span><span class="p">(),</span> <span class="s2">&quot;hypothesis.strategies.random_module()&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="builds"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.builds">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">builds</span><span class="p">(</span>
    <span class="o">*</span><span class="n">callable_and_args</span><span class="p">,</span>  <span class="c1"># type: Any</span>
    <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># type: Union[SearchStrategy[Any], InferType]</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[Any]</span>
    <span class="sd">&quot;&quot;&quot;Generates values by drawing from ``args`` and ``kwargs`` and passing</span>
<span class="sd">    them to the callable (provided as the first positional argument) in the</span>
<span class="sd">    appropriate argument position.</span>

<span class="sd">    e.g. ``builds(target, integers(), flag=booleans())`` would draw an</span>
<span class="sd">    integer ``i`` and a boolean ``b`` and call ``target(i, flag=b)``.</span>

<span class="sd">    If the callable has type annotations, they will be used to infer a strategy</span>
<span class="sd">    for required arguments that were not passed to builds.  You can also tell</span>
<span class="sd">    builds to infer a strategy for an optional argument by passing the special</span>
<span class="sd">    value :const:`hypothesis.infer` as a keyword argument to</span>
<span class="sd">    builds, instead of a strategy for that argument to the callable.</span>

<span class="sd">    If the callable is a class defined with :pypi:`attrs`, missing required</span>
<span class="sd">    arguments will be inferred from the attribute on a best-effort basis,</span>
<span class="sd">    e.g. by checking :ref:`attrs standard validators &lt;attrs:api_validators&gt;`.</span>
<span class="sd">    Dataclasses are handled natively by the inference from type hints.</span>

<span class="sd">    Examples from this strategy shrink by shrinking the argument values to</span>
<span class="sd">    the callable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable_and_args</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;builds() must be passed a callable as the first positional &quot;</span>
            <span class="s2">&quot;argument, but no positional arguments were given.&quot;</span>
        <span class="p">)</span>
    <span class="n">target</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">callable_and_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">callable_and_args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;The first positional argument to builds() must be a callable &quot;</span>
            <span class="s2">&quot;target to construct.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">infer</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="c1"># Avoid an implementation nightmare juggling tuples and worse things</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;infer was passed as a positional argument to &quot;</span>
            <span class="s2">&quot;builds(), but is only allowed as a keyword arg&quot;</span>
        <span class="p">)</span>
    <span class="n">required</span> <span class="o">=</span> <span class="n">required_args</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">to_infer</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">infer</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">required</span> <span class="ow">or</span> <span class="n">to_infer</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="c1"># Use our custom introspection for attrs classes</span>
            <span class="kn">from</span> <span class="nn">hypothesis.searchstrategy.attrs</span> <span class="k">import</span> <span class="n">from_attrs</span>

            <span class="k">return</span> <span class="n">from_attrs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">required</span> <span class="o">|</span> <span class="n">to_infer</span><span class="p">)</span>
        <span class="c1"># Otherwise, try using type hints</span>
        <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_typed_named_tuple</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
                <span class="c1"># Special handling for typing.NamedTuple</span>
                <span class="n">hints</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_field_types</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_infer</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">hints</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;passed infer for </span><span class="si">%s</span><span class="s2">, but there is no type annotation&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">to_infer</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">hints</span><span class="p">))))</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">required</span> <span class="o">|</span> <span class="n">to_infer</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_type</span><span class="p">(</span><span class="n">hints</span><span class="p">[</span><span class="n">kw</span><span class="p">])</span>
    <span class="c1"># Mypy doesn&#39;t realise that `infer` is gone from kwargs now</span>
    <span class="n">kwarg_strat</span> <span class="o">=</span> <span class="n">fixed_dictionaries</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">kwarg_strat</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="n">target</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_defer_from_type</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="c1"># type: (T) -&gt; T</span>
    <span class="sd">&quot;&quot;&quot;Decorator to make from_type lazy to support recursive definitions.&quot;&quot;&quot;</span>

    <span class="nd">@proxies</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">deferred</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">inner</span>


<div class="viewcode-block" id="from_type"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.from_type">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@_defer_from_type</span>
<span class="k">def</span> <span class="nf">from_type</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="c1"># type: (Type[Ex]) -&gt; SearchStrategy[Ex]</span>
    <span class="sd">&quot;&quot;&quot;Looks up the appropriate search strategy for the given type.</span>

<span class="sd">    ``from_type`` is used internally to fill in missing arguments to</span>
<span class="sd">    :func:`~hypothesis.strategies.builds` and can be used interactively</span>
<span class="sd">    to explore what strategies are available or to debug type resolution.</span>

<span class="sd">    You can use :func:`~hypothesis.strategies.register_type_strategy` to</span>
<span class="sd">    handle your custom types, or to globally redefine certain strategies -</span>
<span class="sd">    for example excluding NaN from floats, or use timezone-aware instead of</span>
<span class="sd">    naive time and datetime strategies.</span>

<span class="sd">    The resolution logic may be changed in a future version, but currently</span>
<span class="sd">    tries these four options:</span>

<span class="sd">    1. If ``thing`` is in the default lookup mapping or user-registered lookup,</span>
<span class="sd">       return the corresponding strategy.  The default lookup covers all types</span>
<span class="sd">       with Hypothesis strategies, including extras where possible.</span>
<span class="sd">    2. If ``thing`` is from the :mod:`python:typing` module, return the</span>
<span class="sd">       corresponding strategy (special logic).</span>
<span class="sd">    3. If ``thing`` has one or more subtypes in the merged lookup, return</span>
<span class="sd">       the union of the strategies for those types that are not subtypes of</span>
<span class="sd">       other elements in the lookup.</span>
<span class="sd">    4. Finally, if ``thing`` has type annotations for all required arguments,</span>
<span class="sd">       it is resolved via :func:`~hypothesis.strategies.builds`.</span>

<span class="sd">    There is a valuable recipe for leveraging ``from_type()`` to generate</span>
<span class="sd">    &quot;everything except&quot; values from a specified type. I.e.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def everything_except(excluded_types):</span>
<span class="sd">            return (</span>
<span class="sd">                from_type(type).flatmap(from_type)</span>
<span class="sd">                .filter(lambda x: not isinstance(x, excluded_types))</span>
<span class="sd">            )</span>

<span class="sd">    For example, ``everything_except(int)`` returns a strategy that can</span>
<span class="sd">    generate anything that ``from_type()`` can ever generate, except for</span>
<span class="sd">    instances of :class:`python:int`, and excluding instances of types</span>
<span class="sd">    added via :func:`~hypothesis.strategies.register_type_strategy`.</span>

<span class="sd">    This is useful when writing tests which check that invalid input is</span>
<span class="sd">    rejected in a certain way.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: We would like to move this to the top level, but pending some major</span>
    <span class="c1"># refactoring it&#39;s hard to do without creating circular imports.</span>
    <span class="kn">from</span> <span class="nn">hypothesis.searchstrategy</span> <span class="k">import</span> <span class="n">types</span>

    <span class="k">def</span> <span class="nf">as_strategy</span><span class="p">(</span><span class="n">strat_or_callable</span><span class="p">,</span> <span class="n">thing</span><span class="p">):</span>
        <span class="c1"># User-provided strategies need some validation, and callables even more</span>
        <span class="c1"># of it.  We do this in three places, hence the helper function</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strat_or_callable</span><span class="p">,</span> <span class="n">SearchStrategy</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">strat_or_callable</span><span class="p">)</span>  <span class="c1"># Validated in register_type_strategy</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">strat_or_callable</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">strat_or_callable</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">SearchStrategy</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ResolutionFailed</span><span class="p">(</span>
                <span class="s2">&quot;Error: </span><span class="si">%s</span><span class="s2"> was registered for </span><span class="si">%r</span><span class="s2">, but returned non-strategy </span><span class="si">%r</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">nicerepr</span><span class="p">(</span><span class="n">strat_or_callable</span><span class="p">),</span> <span class="n">strategy</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">strategy</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ResolutionFailed</span><span class="p">(</span><span class="s2">&quot;Error: </span><span class="si">%r</span><span class="s2"> resolved to an empty strategy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thing</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">strategy</span>

    <span class="k">if</span> <span class="n">typing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no branch</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">types</span><span class="o">.</span><span class="n">is_a_new_type</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
                <span class="c1"># Check if we have an explicitly registered strategy for this thing,</span>
                <span class="c1"># resolve it so, and otherwise resolve as for the base type.</span>
                <span class="k">if</span> <span class="n">thing</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">_global_type_lookup</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">as_strategy</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">_global_type_lookup</span><span class="p">[</span><span class="n">thing</span><span class="p">],</span> <span class="n">thing</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">from_type</span><span class="p">(</span><span class="n">thing</span><span class="o">.</span><span class="n">__supertype__</span><span class="p">)</span>
            <span class="c1"># Under Python 3.6, Unions are not instances of `type` - but we</span>
            <span class="c1"># still want to resolve them!</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="s2">&quot;__origin__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">thing</span><span class="o">.</span><span class="n">__args__</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">type_sorting_key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">one_of</span><span class="p">([</span><span class="n">from_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
        <span class="c1"># We can&#39;t resolve forward references, and under Python 3.5 (only)</span>
        <span class="c1"># a forward reference is an instance of type.  Hence, explicit check:</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">typing</span><span class="p">,</span> <span class="s2">&quot;_ForwardRef&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span> <span class="o">==</span> <span class="n">typing</span><span class="o">.</span><span class="n">_ForwardRef</span>
        <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="n">ResolutionFailed</span><span class="p">(</span>
                <span class="s2">&quot;thing=</span><span class="si">%s</span><span class="s2"> cannot be resolved.  Upgrading to python&gt;=3.6 may &quot;</span>
                <span class="s2">&quot;fix this problem via improvements to the typing module.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thing</span><span class="p">,)</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="o">.</span><span class="n">is_a_type</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;thing=</span><span class="si">%s</span><span class="s2"> must be a type&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thing</span><span class="p">,))</span>
    <span class="c1"># Now that we know `thing` is a type, the first step is to check for an</span>
    <span class="c1"># explicitly registered strategy.  This is the best (and hopefully most</span>
    <span class="c1"># common) way to resolve a type to a strategy.  Note that the value in the</span>
    <span class="c1"># lookup may be a strategy or a function from type -&gt; strategy; and we</span>
    <span class="c1"># convert empty results into an explicit error.</span>
    <span class="k">if</span> <span class="n">thing</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">_global_type_lookup</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">as_strategy</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">_global_type_lookup</span><span class="p">[</span><span class="n">thing</span><span class="p">],</span> <span class="n">thing</span><span class="p">)</span>
    <span class="c1"># If there&#39;s no explicitly registered strategy, maybe a subtype of thing</span>
    <span class="c1"># is registered - if so, we can resolve it to the subclass strategy.</span>
    <span class="c1"># We&#39;ll start by checking if thing is from from the typing module,</span>
    <span class="c1"># because there are several special cases that don&#39;t play well with</span>
    <span class="c1"># subclass and instance checks.</span>
    <span class="k">if</span> <span class="n">typing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no branch</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">typing_root_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">from_typing_type</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
    <span class="c1"># If it&#39;s not from the typing module, we get all registered types that are</span>
    <span class="c1"># a subclass of `thing` and are not themselves a subtype of any other such</span>
    <span class="c1"># type.  For example, `Number -&gt; integers() | floats()`, but bools() is</span>
    <span class="c1"># not included because bool is a subclass of int as well as Number.</span>
    <span class="n">strategies</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">as_strategy</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">thing</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">_global_type_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">thing</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">try_issubclass</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">typ</span><span class="p">)</span> <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">_global_type_lookup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">strategies</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">one_of</span><span class="p">(</span><span class="n">strategies</span><span class="p">)</span>
    <span class="c1"># If we don&#39;t have a strategy registered for this type or any subtype, we</span>
    <span class="c1"># may be able to fall back on type annotations.</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sampled_from</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
    <span class="c1"># If we know that builds(thing) will fail, give a better error message</span>
    <span class="n">required</span> <span class="o">=</span> <span class="n">required_args</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">required</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">required</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">thing</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)),</span>
            <span class="n">attr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">thing</span><span class="p">),</span>
            <span class="c1"># NamedTuples are weird enough that we need a specific check for them.</span>
            <span class="n">is_typed_named_tuple</span><span class="p">(</span><span class="n">thing</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">ResolutionFailed</span><span class="p">(</span>
            <span class="s2">&quot;Could not resolve </span><span class="si">%r</span><span class="s2"> to a strategy; consider &quot;</span>
            <span class="s2">&quot;using register_type_strategy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thing</span><span class="p">,)</span>
        <span class="p">)</span>
    <span class="c1"># Finally, try to build an instance by calling the type object</span>
    <span class="k">return</span> <span class="n">builds</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span></div>


<div class="viewcode-block" id="fractions"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.fractions">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">fractions</span><span class="p">(</span>
    <span class="n">min_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Union[Real, AnyStr]</span>
    <span class="n">max_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Union[Real, AnyStr]</span>
    <span class="n">max_denominator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[Fraction]</span>
    <span class="sd">&quot;&quot;&quot;Returns a strategy which generates Fractions.</span>

<span class="sd">    If min_value is not None then all generated values are no less than</span>
<span class="sd">    min_value.  If max_value is not None then all generated values are no</span>
<span class="sd">    greater than max_value.  min_value and max_value may be anything accepted</span>
<span class="sd">    by the :class:`~fractions.Fraction` constructor.</span>

<span class="sd">    If max_denominator is not None then the denominator of any generated</span>
<span class="sd">    values is no greater than max_denominator. Note that max_denominator must</span>
<span class="sd">    be None or a positive integer.</span>

<span class="sd">    Examples from this strategy shrink towards smaller denominators, then</span>
<span class="sd">    closer to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_value</span> <span class="o">=</span> <span class="n">try_convert</span><span class="p">(</span><span class="n">Fraction</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">)</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="n">try_convert</span><span class="p">(</span><span class="n">Fraction</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Unreachable for Mypy&quot;</span>  <span class="c1"># pragma: no cover</span>

    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="n">check_valid_integer</span><span class="p">(</span><span class="n">max_denominator</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_denominator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_denominator</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;max_denominator=</span><span class="si">%r</span><span class="s2"> must be &gt;= 1&quot;</span> <span class="o">%</span> <span class="n">max_denominator</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">fraction_bounds</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># type: (Fraction) -&gt; Tuple[Fraction, Fraction]</span>
            <span class="sd">&quot;&quot;&quot;Find the best lower and upper approximation for value.&quot;&quot;&quot;</span>
            <span class="c1"># Adapted from CPython&#39;s Fraction.limit_denominator here:</span>
            <span class="c1"># https://github.com/python/cpython/blob/3.6/Lib/fractions.py#L219</span>
            <span class="k">assert</span> <span class="n">max_denominator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">denominator</span> <span class="o">&lt;=</span> <span class="n">max_denominator</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="n">value</span>

            <span class="n">p0</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">denominator</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">d</span>
                <span class="n">q2</span> <span class="o">=</span> <span class="n">q0</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">q1</span>
                <span class="k">if</span> <span class="n">q2</span> <span class="o">&gt;</span> <span class="n">max_denominator</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">p0</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">p0</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p1</span><span class="p">,</span> <span class="n">q2</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">d</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_denominator</span> <span class="o">-</span> <span class="n">q0</span><span class="p">)</span> <span class="o">//</span> <span class="n">q1</span>
            <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">q1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">p1</span><span class="p">,</span> <span class="n">q0</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">q1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">high</span>
            <span class="k">return</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span>

        <span class="c1"># Take the high approximation for min_value and low for max_value</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_denominator</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_value</span><span class="o">.</span><span class="n">denominator</span> <span class="o">&gt;</span> <span class="n">max_denominator</span><span class="p">:</span>
                <span class="n">note_deprecation</span><span class="p">(</span>
                    <span class="s2">&quot;The min_value=</span><span class="si">%r</span><span class="s2"> has a denominator greater than the &quot;</span>
                    <span class="s2">&quot;max_denominator=</span><span class="si">%r</span><span class="s2">, which will be an error in a future &quot;</span>
                    <span class="s2">&quot;version.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_denominator</span><span class="p">),</span>
                    <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2018-10-12&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">min_value</span> <span class="o">=</span> <span class="n">fraction_bounds</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_value</span><span class="o">.</span><span class="n">denominator</span> <span class="o">&gt;</span> <span class="n">max_denominator</span><span class="p">:</span>
                <span class="n">note_deprecation</span><span class="p">(</span>
                    <span class="s2">&quot;The max_value=</span><span class="si">%r</span><span class="s2"> has a denominator greater than the &quot;</span>
                    <span class="s2">&quot;max_denominator=</span><span class="si">%r</span><span class="s2">, which will be an error in a future &quot;</span>
                    <span class="s2">&quot;version.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="n">max_denominator</span><span class="p">),</span>
                    <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2018-10-12&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">max_value</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fraction_bounds</span><span class="p">(</span><span class="n">max_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_value</span> <span class="o">&gt;</span> <span class="n">max_value</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;There are no fractions with a denominator &lt;= </span><span class="si">%r</span><span class="s2"> between &quot;</span>
                <span class="s2">&quot;min_value=</span><span class="si">%r</span><span class="s2"> and max_value=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">bounds</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_value</span> <span class="o">==</span> <span class="n">max_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">just</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dm_func</span><span class="p">(</span><span class="n">denom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take denom, construct numerator strategy, and build fraction.&quot;&quot;&quot;</span>
        <span class="c1"># Four cases of algebra to get integer bounds and scale factor.</span>
        <span class="n">min_num</span><span class="p">,</span> <span class="n">max_num</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_num</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">max_value</span><span class="o">.</span><span class="n">numerator</span>
            <span class="n">denom</span> <span class="o">*=</span> <span class="n">max_value</span><span class="o">.</span><span class="n">denominator</span>
        <span class="k">elif</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_num</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">min_value</span><span class="o">.</span><span class="n">numerator</span>
            <span class="n">denom</span> <span class="o">*=</span> <span class="n">min_value</span><span class="o">.</span><span class="n">denominator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">min_value</span><span class="o">.</span><span class="n">numerator</span> <span class="o">*</span> <span class="n">max_value</span><span class="o">.</span><span class="n">denominator</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">max_value</span><span class="o">.</span><span class="n">numerator</span> <span class="o">*</span> <span class="n">min_value</span><span class="o">.</span><span class="n">denominator</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">min_value</span><span class="o">.</span><span class="n">denominator</span> <span class="o">*</span> <span class="n">max_value</span><span class="o">.</span><span class="n">denominator</span>
            <span class="c1"># After calculating our integer bounds and scale factor, we remove</span>
            <span class="c1"># the gcd to avoid drawing more bytes for the example than needed.</span>
            <span class="c1"># Note that `div` can be at most equal to `scale`.</span>
            <span class="n">div</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">gcd</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">))</span>
            <span class="n">min_num</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">low</span> <span class="o">//</span> <span class="n">div</span>
            <span class="n">max_num</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">high</span> <span class="o">//</span> <span class="n">div</span>
            <span class="n">denom</span> <span class="o">*=</span> <span class="n">scale</span> <span class="o">//</span> <span class="n">div</span>

        <span class="k">return</span> <span class="n">builds</span><span class="p">(</span>
            <span class="n">Fraction</span><span class="p">,</span> <span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="n">min_num</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">max_num</span><span class="p">),</span> <span class="n">just</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">max_denominator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatmap</span><span class="p">(</span><span class="n">dm_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">integers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_denominator</span><span class="p">)</span>
        <span class="o">.</span><span class="n">flatmap</span><span class="p">(</span><span class="n">dm_func</span><span class="p">)</span>
        <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="n">max_denominator</span><span class="p">))</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_as_finite_decimal</span><span class="p">(</span>
    <span class="n">value</span><span class="p">,</span>  <span class="c1"># type: Union[Real, AnyStr, None]</span>
    <span class="n">name</span><span class="p">,</span>  <span class="c1"># type: str</span>
    <span class="n">allow_infinity</span><span class="p">,</span>  <span class="c1"># type: Optional[bool]</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; Optional[Decimal]</span>
    <span class="sd">&quot;&quot;&quot;Convert decimal bounds to decimals, carefully.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">()):</span>  <span class="c1"># ensure that default traps are enabled</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">try_convert</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">is_infinite</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">if</span> <span class="s2">&quot;min&quot;</span> <span class="ow">in</span> <span class="n">name</span> <span class="k">else</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">allow_infinity</span> <span class="ow">or</span> <span class="n">allow_infinity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;allow_infinity=</span><span class="si">%r</span><span class="s2">, but </span><span class="si">%s</span><span class="s2">=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">allow_infinity</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># This could be infinity, quiet NaN, or signalling NaN</span>
    <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;Invalid </span><span class="si">%s</span><span class="s2">=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>


<div class="viewcode-block" id="decimals"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.decimals">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">decimals</span><span class="p">(</span>
    <span class="n">min_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Union[Real, AnyStr]</span>
    <span class="n">max_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: Union[Real, AnyStr]</span>
    <span class="n">allow_nan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: bool</span>
    <span class="n">allow_infinity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: bool</span>
    <span class="n">places</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: int</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[Decimal]</span>
    <span class="sd">&quot;&quot;&quot;Generates instances of :class:`python:decimal.Decimal`, which may be:</span>

<span class="sd">    - A finite rational number, between ``min_value`` and ``max_value``.</span>
<span class="sd">    - Not a Number, if ``allow_nan`` is True.  None means &quot;allow NaN, unless</span>
<span class="sd">      ``min_value`` and ``max_value`` are not None&quot;.</span>
<span class="sd">    - Positive or negative infinity, if ``max_value`` and ``min_value``</span>
<span class="sd">      respectively are None, and ``allow_infinity`` is not False.  None means</span>
<span class="sd">      &quot;allow infinity, unless excluded by the min and max values&quot;.</span>

<span class="sd">    Note that where floats have one ``NaN`` value, Decimals have four: signed,</span>
<span class="sd">    and either *quiet* or *signalling*.  See `the decimal module docs</span>
<span class="sd">    &lt;https://docs.python.org/3/library/decimal.html#special-values&gt;`_ for</span>
<span class="sd">    more information on special values.</span>

<span class="sd">    If ``places`` is not None, all finite values drawn from the strategy will</span>
<span class="sd">    have that number of digits after the decimal place.</span>

<span class="sd">    Examples from this strategy do not have a well defined shrink order but</span>
<span class="sd">    try to maximize human readability when shrinking.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert min_value and max_value to Decimal values, and validate args</span>
    <span class="n">check_valid_integer</span><span class="p">(</span><span class="n">places</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">places</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;places=</span><span class="si">%r</span><span class="s2"> may not be negative&quot;</span> <span class="o">%</span> <span class="n">places</span><span class="p">)</span>
    <span class="n">min_value</span> <span class="o">=</span> <span class="n">_as_finite_decimal</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="n">allow_infinity</span><span class="p">)</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="n">_as_finite_decimal</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">,</span> <span class="n">allow_infinity</span><span class="p">)</span>
    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">allow_infinity</span> <span class="ow">and</span> <span class="p">(</span><span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;Cannot allow infinity between finite bounds&quot;</span><span class="p">)</span>
    <span class="c1"># Set up a strategy for finite decimals.  Note that both floating and</span>
    <span class="c1"># fixed-point decimals require careful handling to remain isolated from</span>
    <span class="c1"># any external precision context - in short, we always work out the</span>
    <span class="c1"># required precision for lossless operation and use context methods.</span>
    <span class="k">if</span> <span class="n">places</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Fixed-point decimals are basically integers with a scale factor</span>
        <span class="k">def</span> <span class="nf">ctx</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return a context in which this value is lossless.&quot;&quot;&quot;</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">places</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="nb">max</span><span class="p">([</span><span class="n">precision</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="k">def</span> <span class="nf">int_to_decimal</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">context</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">factor</span><span class="p">),</span> <span class="n">factor</span><span class="p">)</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>
        <span class="n">min_num</span><span class="p">,</span> <span class="n">max_num</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_num</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">ctx</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">factor</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_num</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">ctx</span><span class="p">(</span><span class="n">max_value</span><span class="p">)</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">max_value</span><span class="p">,</span> <span class="n">factor</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">min_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_num</span> <span class="o">&gt;</span> <span class="n">max_num</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                <span class="s2">&quot;There are no decimals with </span><span class="si">%d</span><span class="s2"> places between min_value=</span><span class="si">%r</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;and max_value=</span><span class="si">%r</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">places</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">strat</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="n">min_num</span><span class="p">,</span> <span class="n">max_num</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">int_to_decimal</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, they&#39;re like fractions featuring a power of ten</span>
        <span class="k">def</span> <span class="nf">fraction_to_decimal</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">numerator</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">denominator</span><span class="p">))</span>
                <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">precision</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                <span class="n">Decimal</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">numerator</span><span class="p">),</span> <span class="n">val</span><span class="o">.</span><span class="n">denominator</span>
            <span class="p">)</span>

        <span class="n">strat</span> <span class="o">=</span> <span class="n">fractions</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">fraction_to_decimal</span><span class="p">)</span>
    <span class="c1"># Compose with sampled_from for infinities and NaNs as appropriate</span>
    <span class="n">special</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[Decimal]</span>
    <span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">or</span> <span class="p">(</span><span class="n">allow_nan</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="kc">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">))):</span>
        <span class="n">special</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">,</span> <span class="s2">&quot;-NaN&quot;</span><span class="p">,</span> <span class="s2">&quot;sNaN&quot;</span><span class="p">,</span> <span class="s2">&quot;-sNaN&quot;</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">allow_infinity</span> <span class="ow">or</span> <span class="p">(</span><span class="n">allow_infinity</span> <span class="ow">is</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">special</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;Infinity&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">allow_infinity</span> <span class="ow">or</span> <span class="p">(</span><span class="n">allow_infinity</span> <span class="ow">is</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">special</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;-Infinity&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">strat</span> <span class="o">|</span> <span class="p">(</span><span class="n">sampled_from</span><span class="p">(</span><span class="n">special</span><span class="p">)</span> <span class="k">if</span> <span class="n">special</span> <span class="k">else</span> <span class="n">nothing</span><span class="p">())</span></div>


<div class="viewcode-block" id="recursive"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.recursive">[docs]</a><span class="k">def</span> <span class="nf">recursive</span><span class="p">(</span>
    <span class="n">base</span><span class="p">,</span>  <span class="c1"># type: SearchStrategy[Ex]</span>
    <span class="n">extend</span><span class="p">,</span>  <span class="c1"># type: Callable[[SearchStrategy[Any]], SearchStrategy[T]]</span>
    <span class="n">max_leaves</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>  <span class="c1"># type: int</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[Union[T, Ex]]</span>
    <span class="sd">&quot;&quot;&quot;base: A strategy to start from.</span>

<span class="sd">    extend: A function which takes a strategy and returns a new strategy.</span>

<span class="sd">    max_leaves: The maximum number of elements to be drawn from base on a given</span>
<span class="sd">    run.</span>

<span class="sd">    This returns a strategy ``S`` such that ``S = extend(base | S)``. That is,</span>
<span class="sd">    values may be drawn from base, or from any strategy reachable by mixing</span>
<span class="sd">    applications of | and extend.</span>

<span class="sd">    An example may clarify: ``recursive(booleans(), lists)`` would return a</span>
<span class="sd">    strategy that may return arbitrarily nested and mixed lists of booleans.</span>
<span class="sd">    So e.g. ``False``, ``[True]``, ``[False, []]``, and ``[[[[True]]]]`` are</span>
<span class="sd">    all valid values to be drawn from that strategy.</span>

<span class="sd">    Examples from this strategy shrink by trying to reduce the amount of</span>
<span class="sd">    recursion and by shrinking according to the shrinking behaviour of base</span>
<span class="sd">    and the result of extend.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">RecursiveStrategy</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">extend</span><span class="p">,</span> <span class="n">max_leaves</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">PermutationStrategy</span><span class="p">(</span><span class="n">SearchStrategy</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">do_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># Reversed Fisher-Yates shuffle: swap each element with itself or with</span>
        <span class="c1"># a later element.  This shrinks i==j for each element, i.e. to no</span>
        <span class="c1"># change.  We don&#39;t consider the last element as it&#39;s always a no-op.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">integer_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="permutations"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.permutations">[docs]</a><span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="c1"># type: (Sequence[T]) -&gt; SearchStrategy[List[T]]</span>
    <span class="sd">&quot;&quot;&quot;Return a strategy which returns permutations of the ordered collection</span>
<span class="sd">    ``values``.</span>

<span class="sd">    Examples from this strategy shrink by trying to become closer to the</span>
<span class="sd">    original order of values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">check_sample</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;permutations&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builds</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">PermutationStrategy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="datetimes"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.datetimes">[docs]</a><span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">datetimes</span><span class="p">(</span>
    <span class="n">min_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>  <span class="c1"># type: dt.datetime</span>
    <span class="n">max_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>  <span class="c1"># type: dt.datetime</span>
    <span class="n">timezones</span><span class="o">=</span><span class="n">none</span><span class="p">(),</span>  <span class="c1"># type: SearchStrategy[Optional[dt.tzinfo]]</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; SearchStrategy[dt.datetime]</span>
    <span class="sd">&quot;&quot;&quot;A strategy for generating datetimes, which may be timezone-aware.</span>

<span class="sd">    This strategy works by drawing a naive datetime between ``min_value``</span>
<span class="sd">    and ``max_value``, which must both be naive (have no timezone).</span>

<span class="sd">    ``timezones`` must be a strategy that generates</span>
<span class="sd">    :class:`~python:datetime.tzinfo` objects (or None,</span>
<span class="sd">    which is valid for naive datetimes).  A value drawn from this strategy</span>
<span class="sd">    will be added to a naive datetime, and the resulting tz-aware datetime</span>
<span class="sd">    returned.</span>

<span class="sd">    .. note::</span>
<span class="sd">        tz-aware datetimes from this strategy may be ambiguous or non-existent</span>
<span class="sd">        due to daylight savings, leap seconds, timezone and calendar</span>
<span class="sd">        adjustments, etc.  This is intentional, as malformed timestamps are a</span>
<span class="sd">        common source of bugs.</span>

<span class="sd">    :py:func:`hypothesis.extra.pytz.timezones` requires the :pypi:`pytz`</span>
<span class="sd">    package, but provides all timezones in the Olsen database.  If you want to</span>
<span class="sd">    allow naive datetimes, combine strategies like ``none() | timezones()``.</span>

<span class="sd">    :py:func:`hypothesis.extra.dateutil.timezones` requires the</span>
<span class="sd">    :pypi:`python-dateutil` package, and similarly provides all timezones</span>
<span class="sd">    there.</span>

<span class="sd">    Alternatively, you can create a list of the timezones you wish to allow</span>
<span class="sd">    (e.g. from the standard library, ``datetutil``, or ``pytz``) and use</span>
<span class="sd">    :py:func:`sampled_from`.  Ensure that simple values such as None or UTC</span>
<span class="sd">    are at the beginning of the list for proper minimisation.</span>

<span class="sd">    Examples from this strategy shrink towards midnight on January 1st 2000.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Why must bounds be naive?  In principle, we could also write a strategy</span>
    <span class="c1"># that took aware bounds, but the API and validation is much harder.</span>
    <span class="c1"># If you want to generate datetimes between two particular momements in</span>
    <span class="c1"># time I suggest (a) just filtering out-of-bounds values; (b) if bounds</span>
    <span class="c1"># are very close, draw a value and subtract its UTC offset, handling</span>
    <span class="c1"># overflows and nonexistent times; or (c) do something customised to</span>
    <span class="c1"># handle datetimes in e.g. a four-microsecond span which is not</span>
    <span class="c1"># representable in UTC.  Handling (d), all of the above, leads to a much</span>
    <span class="c1"># more complex API for all users and a useful feature for very few.</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">)</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_value</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;min_value=</span><span class="si">%r</span><span class="s2"> must not have tzinfo&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">min_value</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">max_value</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;max_value=</span><span class="si">%r</span><span class="s2"> must not have tzinfo&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">max_value</span><span class="p">,))</span>
    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timezones</span><span class="p">,</span> <span class="n">SearchStrategy</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;timezones=</span><span class="si">%r</span><span class="s2"> must be a SearchStrategy that can provide tzinfo &quot;</span>
            <span class="s2">&quot;for datetimes (either None or dt.tzinfo objects)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">timezones</span><span class="p">,)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">DatetimeStrategy</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="n">timezones</span><span class="p">)</span></div>


<div class="viewcode-block" id="dates"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.dates">[docs]</a><span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">dates</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">max</span><span class="p">):</span>
    <span class="c1"># type: (dt.date, dt.date) -&gt; SearchStrategy[dt.date]</span>
    <span class="sd">&quot;&quot;&quot;A strategy for dates between ``min_value`` and ``max_value``.</span>

<span class="sd">    Examples from this strategy shrink towards January 1st 2000.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">)</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_value</span> <span class="o">==</span> <span class="n">max_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">just</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DateStrategy</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="times"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.times">[docs]</a><span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">timezones</span><span class="o">=</span><span class="n">none</span><span class="p">()):</span>
    <span class="c1"># type: (dt.time, dt.time, SearchStrategy) -&gt; SearchStrategy[dt.time]</span>
    <span class="sd">&quot;&quot;&quot;A strategy for times between ``min_value`` and ``max_value``.</span>

<span class="sd">    The ``timezones`` argument is handled as for :py:func:`datetimes`.</span>

<span class="sd">    Examples from this strategy shrink towards midnight, with the timezone</span>
<span class="sd">    component shrinking as for the strategy that provided it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">)</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_value</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;min_value=</span><span class="si">%r</span><span class="s2"> must not have tzinfo&quot;</span> <span class="o">%</span> <span class="n">min_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_value</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;max_value=</span><span class="si">%r</span><span class="s2"> must not have tzinfo&quot;</span> <span class="o">%</span> <span class="n">max_value</span><span class="p">)</span>
    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="n">day</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">datetimes</span><span class="p">(</span>
        <span class="n">min_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">min_value</span><span class="p">),</span>
        <span class="n">max_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">max_value</span><span class="p">),</span>
        <span class="n">timezones</span><span class="o">=</span><span class="n">timezones</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">timetz</span><span class="p">())</span></div>


<div class="viewcode-block" id="timedeltas"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.timedeltas">[docs]</a><span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">timedeltas</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="o">.</span><span class="n">max</span><span class="p">):</span>
    <span class="c1"># type: (dt.timedelta, dt.timedelta) -&gt; SearchStrategy[dt.timedelta]</span>
    <span class="sd">&quot;&quot;&quot;A strategy for timedeltas between ``min_value`` and ``max_value``.</span>

<span class="sd">    Examples from this strategy shrink towards zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">)</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="s2">&quot;min_value&quot;</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_value</span> <span class="o">==</span> <span class="n">max_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">just</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TimedeltaStrategy</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">max_value</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">CompositeStrategy</span><span class="p">(</span><span class="n">SearchStrategy</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">definition</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">definition</span> <span class="o">=</span> <span class="n">definition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">do_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">definition</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">draw</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calc_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__label</span>


<div class="viewcode-block" id="composite"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.composite">[docs]</a><span class="nd">@cacheable</span>
<span class="k">def</span> <span class="nf">composite</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="c1"># type: (Callable[..., Ex]) -&gt; Callable[..., SearchStrategy[Ex]]</span>
    <span class="sd">&quot;&quot;&quot;Defines a strategy that is built out of potentially arbitrarily many</span>
<span class="sd">    other strategies.</span>

<span class="sd">    This is intended to be used as a decorator. See</span>
<span class="sd">    :ref:`the full documentation for more details &lt;composite-strategies&gt;`</span>
<span class="sd">    about how to use this function.</span>

<span class="sd">    Examples from this strategy shrink by shrinking the output of each draw</span>
<span class="sd">    call.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">argspec</span> <span class="o">=</span> <span class="n">getfullargspec</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">argspec</span><span class="o">.</span><span class="n">defaults</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">defaults</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;A default value for initial argument will never be used&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">argspec</span><span class="o">.</span><span class="n">varargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;Functions wrapped with composite must take at least one &quot;</span>
            <span class="s2">&quot;positional argument.&quot;</span>
        <span class="p">)</span>

    <span class="n">annots</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">argspec</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="n">argspec</span><span class="o">.</span><span class="n">kwonlyargs</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;return&quot;</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="n">new_argspec</span> <span class="o">=</span> <span class="n">argspec</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">annotations</span><span class="o">=</span><span class="n">annots</span><span class="p">)</span>

    <span class="n">label</span> <span class="o">=</span> <span class="n">calc_label_from_cls</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@defines_strategy</span>
    <span class="nd">@define_function_signature</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="n">new_argspec</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CompositeStrategy</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="n">accept</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__module__</span>
    <span class="k">return</span> <span class="n">accept</span></div>


<div class="viewcode-block" id="complex_numbers"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.complex_numbers">[docs]</a><span class="nd">@defines_strategy_with_reusable_values</span>
<span class="nd">@cacheable</span>
<span class="k">def</span> <span class="nf">complex_numbers</span><span class="p">(</span>
    <span class="n">min_magnitude</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_magnitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_infinity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="c1"># type: (Optional[Real], Real, bool, bool) -&gt; SearchStrategy[complex]</span>
    <span class="sd">&quot;&quot;&quot;Returns a strategy that generates complex numbers.</span>

<span class="sd">    This strategy draws complex numbers with constrained magnitudes.</span>
<span class="sd">    The ``min_magnitude`` and ``max_magnitude`` parameters should be</span>
<span class="sd">    non-negative :class:`~python:numbers.Real` numbers; values</span>
<span class="sd">    of ``None`` correspond to zero and infinite values respectively.</span>

<span class="sd">    If ``min_magnitude`` is positive or ``max_magnitude`` is finite, it</span>
<span class="sd">    is an error to enable ``allow_nan``.  If ``max_magnitude`` is finite,</span>
<span class="sd">    it is an error to enable ``allow_infinity``.</span>

<span class="sd">    The magnitude contraints are respected up to a relative error</span>
<span class="sd">    of (around) floating-point epsilon, due to implementation via</span>
<span class="sd">    the system ``sqrt`` function.</span>

<span class="sd">    Examples from this strategy shrink by shrinking their real and</span>
<span class="sd">    imaginary parts, as :func:`~hypothesis.strategies.floats`.</span>

<span class="sd">    If you need to generate complex numbers with particular real and</span>
<span class="sd">    imaginary parts or relationships between parts, consider using</span>
<span class="sd">    :func:`builds(complex, ...) &lt;hypothesis.strategies.builds&gt;` or</span>
<span class="sd">    :func:`@composite &lt;hypothesis.strategies.composite&gt;` respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_valid_magnitude</span><span class="p">(</span><span class="n">min_magnitude</span><span class="p">,</span> <span class="s2">&quot;min_magnitude&quot;</span><span class="p">)</span>
    <span class="n">check_valid_magnitude</span><span class="p">(</span><span class="n">max_magnitude</span><span class="p">,</span> <span class="s2">&quot;max_magnitude&quot;</span><span class="p">)</span>
    <span class="n">check_valid_interval</span><span class="p">(</span><span class="n">min_magnitude</span><span class="p">,</span> <span class="n">max_magnitude</span><span class="p">,</span> <span class="s2">&quot;min_magnitude&quot;</span><span class="p">,</span> <span class="s2">&quot;max_magnitude&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_magnitude</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
        <span class="n">max_magnitude</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">min_magnitude</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">min_magnitude</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">allow_infinity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">allow_infinity</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">max_magnitude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">allow_infinity</span> <span class="ow">and</span> <span class="n">max_magnitude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;Cannot have allow_infinity=</span><span class="si">%r</span><span class="s2"> with max_magnitude=</span><span class="si">%r</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">allow_infinity</span><span class="p">,</span> <span class="n">max_magnitude</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">allow_nan</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">min_magnitude</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_magnitude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">min_magnitude</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_magnitude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;Cannot have allow_nan=</span><span class="si">%r</span><span class="s2">, min_magnitude=</span><span class="si">%r</span><span class="s2"> max_magnitude=</span><span class="si">%r</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">allow_nan</span><span class="p">,</span> <span class="n">min_magnitude</span><span class="p">,</span> <span class="n">max_magnitude</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">allow_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span> <span class="n">allow_infinity</span><span class="o">=</span><span class="n">allow_infinity</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">min_magnitude</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_magnitude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># In this simple but common case, there are no constraints on the</span>
        <span class="c1"># magnitude and therefore no relationship between the real and</span>
        <span class="c1"># imaginary parts.</span>
        <span class="k">return</span> <span class="n">builds</span><span class="p">(</span><span class="nb">complex</span><span class="p">,</span> <span class="n">floats</span><span class="p">(</span><span class="o">**</span><span class="n">allow_kw</span><span class="p">),</span> <span class="n">floats</span><span class="p">(</span><span class="o">**</span><span class="n">allow_kw</span><span class="p">))</span>

    <span class="nd">@composite</span>
    <span class="k">def</span> <span class="nf">constrained_complex</span><span class="p">(</span><span class="n">draw</span><span class="p">):</span>
        <span class="c1"># Draw the imaginary part, and determine the maximum real part given</span>
        <span class="c1"># this and the max_magnitude</span>
        <span class="k">if</span> <span class="n">max_magnitude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">floats</span><span class="p">(</span><span class="o">**</span><span class="n">allow_kw</span><span class="p">))</span>
            <span class="n">rmax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">floats</span><span class="p">(</span><span class="o">-</span><span class="n">max_magnitude</span><span class="p">,</span> <span class="n">max_magnitude</span><span class="p">,</span> <span class="o">**</span><span class="n">allow_kw</span><span class="p">))</span>
            <span class="n">rmax</span> <span class="o">=</span> <span class="n">cathetus</span><span class="p">(</span><span class="n">max_magnitude</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
        <span class="c1"># Draw the real part from the allowed range given the imaginary part</span>
        <span class="k">if</span> <span class="n">min_magnitude</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_magnitude</span><span class="p">:</span>
            <span class="n">zr</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">floats</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">rmax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="o">-</span><span class="n">rmax</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="o">**</span><span class="n">allow_kw</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zr</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">floats</span><span class="p">(</span><span class="n">cathetus</span><span class="p">(</span><span class="n">min_magnitude</span><span class="p">,</span> <span class="n">zi</span><span class="p">),</span> <span class="n">rmax</span><span class="p">,</span> <span class="o">**</span><span class="n">allow_kw</span><span class="p">))</span>
        <span class="c1"># Order of conditions carefully tuned so that for a given pair of</span>
        <span class="c1"># magnitude arguments, we always either draw or do not draw the bool</span>
        <span class="c1"># (crucial for good shrinking behaviour) but only invert when needed.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">min_magnitude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">draw</span><span class="p">(</span><span class="n">booleans</span><span class="p">())</span>
            <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_magnitude</span>
        <span class="p">):</span>
            <span class="n">zr</span> <span class="o">=</span> <span class="o">-</span><span class="n">zr</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">zr</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">constrained_complex</span><span class="p">()</span></div>


<div class="viewcode-block" id="shared"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.shared">[docs]</a><span class="k">def</span> <span class="nf">shared</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># type: (SearchStrategy[Ex], Any) -&gt; SearchStrategy[Ex]</span>
    <span class="sd">&quot;&quot;&quot;Returns a strategy that draws a single shared value per run, drawn from</span>
<span class="sd">    base. Any two shared instances with the same key will share the same value,</span>
<span class="sd">    otherwise the identity of this strategy will be used. That is:</span>

<span class="sd">    &gt;&gt;&gt; s = integers()  # or any other strategy</span>
<span class="sd">    &gt;&gt;&gt; x = shared(s)</span>
<span class="sd">    &gt;&gt;&gt; y = shared(s)</span>

<span class="sd">    In the above x and y may draw different (or potentially the same) values.</span>
<span class="sd">    In the following they will always draw the same:</span>

<span class="sd">    &gt;&gt;&gt; x = shared(s, key=&quot;hi&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y = shared(s, key=&quot;hi&quot;)</span>

<span class="sd">    Examples from this strategy shrink as per their base strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">SharedStrategy</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="uuids"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.uuids">[docs]</a><span class="nd">@cacheable</span>
<span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">uuids</span><span class="p">(</span><span class="n">version</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># type: (int) -&gt; SearchStrategy[UUID]</span>
    <span class="sd">&quot;&quot;&quot;Returns a strategy that generates :class:`UUIDs &lt;uuid.UUID&gt;`.</span>

<span class="sd">    If the optional version argument is given, value is passed through</span>
<span class="sd">    to :class:`~python:uuid.UUID` and only UUIDs of that version will</span>
<span class="sd">    be generated.</span>

<span class="sd">    All returned values from this will be unique, so e.g. if you do</span>
<span class="sd">    ``lists(uuids())`` the resulting list will never contain duplicates.</span>

<span class="sd">    Examples from this strategy don&#39;t have any meaningful shrink order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;version=</span><span class="si">%r</span><span class="s2">, but version must be in (None, 1, 2, 3, 4, 5) &quot;</span>
                <span class="s2">&quot;to pass to the uuid.UUID constructor.&quot;</span>
            <span class="p">)</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">version</span><span class="p">,)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">shared</span><span class="p">(</span><span class="n">randoms</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;hypothesis.strategies.uuids.generator&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">UUID</span><span class="p">(</span><span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">,</span> <span class="nb">int</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
    <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">RunnerStrategy</span><span class="p">(</span><span class="n">SearchStrategy</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">do_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">runner</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;hypothesis_runner&quot;</span><span class="p">,</span> <span class="n">not_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">runner</span> <span class="ow">is</span> <span class="n">not_set</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">not_set</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot use runner() strategy with no &quot;</span>
                    <span class="s2">&quot;associated runner or explicit default.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">runner</span>


<div class="viewcode-block" id="runner"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.runner">[docs]</a><span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">runner</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">not_set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A strategy for getting &quot;the current test runner&quot;, whatever that may be.</span>
<span class="sd">    The exact meaning depends on the entry point, but it will usually be the</span>
<span class="sd">    associated &#39;self&#39; value for it.</span>

<span class="sd">    If there is no current test runner and a default is provided, return</span>
<span class="sd">    that default. If no default is provided, raises InvalidArgument.</span>

<span class="sd">    Examples from this strategy do not shrink (because there is only one).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">RunnerStrategy</span><span class="p">(</span><span class="n">default</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataObject"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.DataObject">[docs]</a><span class="k">class</span> <span class="nc">DataObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This type only exists so that you can write type hints for tests using</span>
<span class="sd">    the :func:`~hypothesis.strategies.data` strategy.  Do not use it directly!</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Note that &quot;only exists&quot; here really means &quot;is only exported to users&quot;,</span>
    <span class="c1"># but we want to treat it as &quot;semi-stable&quot;, not document it as &quot;public API&quot;.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conjecture_data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;data(...)&quot;</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># type: (SearchStrategy[Ex], Any) -&gt; Ex</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conjecture_data</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">note</span><span class="p">(</span><span class="s2">&quot;Draw </span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">): </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">note</span><span class="p">(</span><span class="s2">&quot;Draw </span><span class="si">%d</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span></div>


<span class="k">class</span> <span class="nc">DataStrategy</span><span class="p">(</span><span class="n">SearchStrategy</span><span class="p">):</span>
    <span class="n">supports_find</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">do_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">can_reproduce_example_from_repr</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;hypothesis_shared_data_strategy&quot;</span><span class="p">):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">hypothesis_shared_data_strategy</span> <span class="o">=</span> <span class="n">DataObject</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">hypothesis_shared_data_strategy</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;data()&quot;</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__not_a_first_class_strategy</span><span class="p">(</span><span class="s2">&quot;map&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__not_a_first_class_strategy</span><span class="p">(</span><span class="s2">&quot;filter&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__not_a_first_class_strategy</span><span class="p">(</span><span class="s2">&quot;flatmap&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__not_a_first_class_strategy</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__not_a_first_class_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;Cannot call </span><span class="si">%s</span><span class="s2"> on a DataStrategy. You should probably be using &quot;</span>
            <span class="s2">&quot;@composite for whatever it is you&#39;re trying to do.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
        <span class="p">)</span>


<div class="viewcode-block" id="data"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.data">[docs]</a><span class="nd">@cacheable</span>
<span class="k">def</span> <span class="nf">data</span><span class="p">():</span>
    <span class="c1"># type: () -&gt; SearchStrategy[DataObject]</span>
    <span class="sd">&quot;&quot;&quot;This isn&#39;t really a normal strategy, but instead gives you an object</span>
<span class="sd">    which can be used to draw data interactively from other strategies.</span>

<span class="sd">    See :ref:`the rest of the documentation &lt;interactive-draw&gt;` for more</span>
<span class="sd">    complete information.</span>

<span class="sd">    Examples from this strategy do not shrink (because there is only one),</span>
<span class="sd">    but the result of calls to each draw() call shrink as they normally would.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">DataStrategy</span><span class="p">()</span></div>


<div class="viewcode-block" id="register_type_strategy"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.register_type_strategy">[docs]</a><span class="k">def</span> <span class="nf">register_type_strategy</span><span class="p">(</span>
    <span class="n">custom_type</span><span class="p">,</span>  <span class="c1"># type: type</span>
    <span class="n">strategy</span><span class="p">,</span>  <span class="c1"># type: Union[SearchStrategy, Callable[[type], SearchStrategy]]</span>
<span class="p">):</span>
    <span class="c1"># type: (...) -&gt; None</span>
    <span class="sd">&quot;&quot;&quot;Add an entry to the global type-to-strategy lookup.</span>

<span class="sd">    This lookup is used in :func:`~hypothesis.strategies.builds` and</span>
<span class="sd">    :func:`@given &lt;hypothesis.given&gt;`.</span>

<span class="sd">    :func:`~hypothesis.strategies.builds` will be used automatically for</span>
<span class="sd">    classes with type annotations on ``__init__`` , so you only need to</span>
<span class="sd">    register a strategy if one or more arguments need to be more tightly</span>
<span class="sd">    defined than their type-based default, or if you want to supply a strategy</span>
<span class="sd">    for an argument with a default value.</span>

<span class="sd">    ``strategy`` may be a search strategy, or a function that takes a type and</span>
<span class="sd">    returns a strategy (useful for generic types).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: We would like to move this to the top level, but pending some major</span>
    <span class="c1"># refactoring it&#39;s hard to do without creating circular imports.</span>
    <span class="kn">from</span> <span class="nn">hypothesis.searchstrategy</span> <span class="k">import</span> <span class="n">types</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="o">.</span><span class="n">is_a_type</span><span class="p">(</span><span class="n">custom_type</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;custom_type=</span><span class="si">%r</span><span class="s2"> must be a type&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">SearchStrategy</span><span class="p">)</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">strategy</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;strategy=</span><span class="si">%r</span><span class="s2"> must be a SearchStrategy, or a function that takes &quot;</span>
            <span class="s2">&quot;a generic type and returns a specific SearchStrategy&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">SearchStrategy</span><span class="p">)</span> <span class="ow">and</span> <span class="n">strategy</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;strategy=</span><span class="si">%r</span><span class="s2"> must not be empty&quot;</span><span class="p">)</span>
    <span class="n">types</span><span class="o">.</span><span class="n">_global_type_lookup</span><span class="p">[</span><span class="n">custom_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">strategy</span>
    <span class="n">from_type</span><span class="o">.</span><span class="n">__clear_cache</span><span class="p">()</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="deferred"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.deferred">[docs]</a><span class="nd">@cacheable</span>
<span class="k">def</span> <span class="nf">deferred</span><span class="p">(</span><span class="n">definition</span><span class="p">):</span>
    <span class="c1"># type: (Callable[[], SearchStrategy[Ex]]) -&gt; SearchStrategy[Ex]</span>
    <span class="sd">&quot;&quot;&quot;A deferred strategy allows you to write a strategy that references other</span>
<span class="sd">    strategies that have not yet been defined. This allows for the easy</span>
<span class="sd">    definition of recursive and mutually recursive strategies.</span>

<span class="sd">    The definition argument should be a zero-argument function that returns a</span>
<span class="sd">    strategy. It will be evaluated the first time the strategy is used to</span>
<span class="sd">    produce an example.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    &gt;&gt;&gt; import hypothesis.strategies as st</span>
<span class="sd">    &gt;&gt;&gt; x = st.deferred(lambda: st.booleans() | st.tuples(x, x))</span>
<span class="sd">    &gt;&gt;&gt; x.example()</span>
<span class="sd">    (((False, (True, True)), (False, True)), (True, True))</span>
<span class="sd">    &gt;&gt;&gt; x.example()</span>
<span class="sd">    True</span>

<span class="sd">    Mutual recursion also works fine:</span>

<span class="sd">    &gt;&gt;&gt; a = st.deferred(lambda: st.booleans() | b)</span>
<span class="sd">    &gt;&gt;&gt; b = st.deferred(lambda: st.tuples(a, a))</span>
<span class="sd">    &gt;&gt;&gt; a.example()</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b.example()</span>
<span class="sd">    (False, (False, ((False, True), False)))</span>

<span class="sd">    Examples from this strategy shrink as they normally would from the strategy</span>
<span class="sd">    returned by the definition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">DeferredStrategy</span><span class="p">(</span><span class="n">definition</span><span class="p">)</span></div>


<div class="viewcode-block" id="emails"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.emails">[docs]</a><span class="nd">@defines_strategy_with_reusable_values</span>
<span class="k">def</span> <span class="nf">emails</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;A strategy for generating email addresses as unicode strings. The</span>
<span class="sd">    address format is specified in :rfc:`5322#section-3.4.1`. Values shrink</span>
<span class="sd">    towards shorter local-parts and host domains.</span>

<span class="sd">    This strategy is useful for generating &quot;user data&quot; for tests, as</span>
<span class="sd">    mishandling of email addresses is a common source of bugs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">hypothesis.provisional</span> <span class="k">import</span> <span class="n">domains</span>

    <span class="n">local_chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;!#$%&amp;&#39;*+-/=^_`{|}~&quot;</span>
    <span class="n">local_part</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="n">local_chars</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
    <span class="c1"># TODO: include dot-atoms, quoted strings, escaped chars, etc in local part</span>
    <span class="k">return</span> <span class="n">builds</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">@</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">local_part</span><span class="p">,</span> <span class="n">domains</span><span class="p">())</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">addr</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">254</span>
    <span class="p">)</span></div>


<span class="c1"># Mypy can&#39;t yet handle default values with generic types or typevars, but the</span>
<span class="c1"># @overload workaround from https://github.com/python/mypy/issues/3737 doesn&#39;t</span>
<span class="c1"># work with @composite functions - Mypy can&#39;t see that the function implements</span>
<span class="c1"># `(Any, Callable[..., T], SearchStrategy[T]) -&gt; Callable[..., T]`</span>


<div class="viewcode-block" id="functions"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.functions">[docs]</a><span class="nd">@defines_strategy</span>
<span class="k">def</span> <span class="nf">functions</span><span class="p">(</span><span class="n">like</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">returns</span><span class="o">=</span><span class="n">none</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;A strategy for functions, which can be used in callbacks.</span>

<span class="sd">    The generated functions will mimic the interface of ``like``, which must</span>
<span class="sd">    be a callable (including a class, method, or function).  The return value</span>
<span class="sd">    for the function is drawn from the ``returns`` argument, which must be a</span>
<span class="sd">    strategy.</span>

<span class="sd">    Note that the generated functions do not validate their arguments, and</span>
<span class="sd">    may return a different value if called again with the same arguments.</span>

<span class="sd">    Generated functions can only be called within the scope of the ``@given``</span>
<span class="sd">    which created them.  This strategy does not support ``.example()``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">SearchStrategy</span><span class="p">,</span> <span class="n">returns</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">like</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span>
            <span class="s2">&quot;The first argument to functions() must be a callable to imitate, &quot;</span>
            <span class="s2">&quot;but got non-callable like=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nicerepr</span><span class="p">(</span><span class="n">like</span><span class="p">),)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">FunctionStrategy</span><span class="p">(</span><span class="n">like</span><span class="p">,</span> <span class="n">returns</span><span class="p">)</span></div>


<div class="viewcode-block" id="slices"><a class="viewcode-back" href="../../data.html#hypothesis.strategies.slices">[docs]</a><span class="nd">@composite</span>
<span class="k">def</span> <span class="nf">slices</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates slices that will select indices up to the supplied size</span>

<span class="sd">    Generated slices will have start and stop indices that range from 0 to size - 1</span>
<span class="sd">    and will step in the appropriate direction. Slices should only produce an empty selection</span>
<span class="sd">    if the start and end are the same.</span>

<span class="sd">    Examples from this strategy shrink toward 0 and smaller values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_valid_integer</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidArgument</span><span class="p">(</span><span class="s2">&quot;size=</span><span class="si">%r</span><span class="s2"> must be at least one&quot;</span> <span class="o">%</span> <span class="n">size</span><span class="p">)</span>

    <span class="n">min_start</span> <span class="o">=</span> <span class="n">min_stop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_start</span> <span class="o">=</span> <span class="n">max_stop</span> <span class="o">=</span> <span class="n">size</span>
    <span class="n">min_step</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># For slices start is inclusive and stop is exclusive</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">integers</span><span class="p">(</span><span class="n">min_start</span><span class="p">,</span> <span class="n">max_start</span><span class="p">)</span> <span class="o">|</span> <span class="n">none</span><span class="p">())</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">integers</span><span class="p">(</span><span class="n">min_stop</span><span class="p">,</span> <span class="n">max_stop</span><span class="p">)</span> <span class="o">|</span> <span class="n">none</span><span class="p">())</span>

    <span class="c1"># Limit step size to be reasonable</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_step</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_step</span> <span class="o">=</span> <span class="n">stop</span>
    <span class="k">elif</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_step</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_step</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">stop</span><span class="p">)</span>

    <span class="n">step</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">integers</span><span class="p">(</span><span class="n">min_step</span><span class="p">,</span> <span class="n">max_step</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stop</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">step</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2019, David R. MacIver

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>